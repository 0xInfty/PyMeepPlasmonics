# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
from . import _meep
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _meep.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _meep.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _meep.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _meep.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _meep.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _meep.SwigPyIterator_equal(self, x)

    def copy(self):
        return _meep.SwigPyIterator_copy(self)

    def next(self):
        return _meep.SwigPyIterator_next(self)

    def __next__(self):
        return _meep.SwigPyIterator___next__(self)

    def previous(self):
        return _meep.SwigPyIterator_previous(self)

    def advance(self, n):
        return _meep.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _meep.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _meep.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _meep.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _meep.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _meep.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _meep.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _meep.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

py_pml_profile = _meep.py_pml_profile
py_master_printf_wrap = _meep.py_master_printf_wrap
py_master_printf_stderr_wrap = _meep.py_master_printf_stderr_wrap

def set_ctl_printf_callback(callback):
    return _meep.set_ctl_printf_callback(callback)
set_ctl_printf_callback = _meep.set_ctl_printf_callback

def set_mpb_printf_callback(callback):
    return _meep.set_mpb_printf_callback(callback)
set_mpb_printf_callback = _meep.set_mpb_printf_callback

def py_do_harminv(vals, dt, f_min, f_max, maxbands, spectral_density, Q_thresh, rel_err_thresh, err_thresh, rel_amp_thresh, amp_thresh):
    return _meep.py_do_harminv(vals, dt, f_min, f_max, maxbands, spectral_density, Q_thresh, rel_err_thresh, err_thresh, rel_amp_thresh, amp_thresh)
py_do_harminv = _meep.py_do_harminv

def _get_farfield(f, v):
    return _meep._get_farfield(f, v)
_get_farfield = _meep._get_farfield

def _get_farfields_array(n2f, where, resolution):
    return _meep._get_farfields_array(n2f, where, resolution)
_get_farfields_array = _meep._get_farfields_array

def _dft_ldos_ldos(f):
    return _meep._dft_ldos_ldos(f)
_dft_ldos_ldos = _meep._dft_ldos_ldos

def _dft_ldos_F(f):
    return _meep._dft_ldos_F(f)
_dft_ldos_F = _meep._dft_ldos_F

def _dft_ldos_J(f):
    return _meep._dft_ldos_J(f)
_dft_ldos_J = _meep._dft_ldos_J

def _get_dft_data_size(dc):
    return _meep._get_dft_data_size(dc)
_get_dft_data_size = _meep._get_dft_data_size

def _get_dft_data(dc, cdata):
    return _meep._get_dft_data(dc, cdata)
_get_dft_data = _meep._get_dft_data

def _load_dft_data(dc, cdata):
    return _meep._load_dft_data(dc, cdata)
_load_dft_data = _meep._load_dft_data

def make_volume_list(v, c, weight, next):
    return _meep.make_volume_list(v, c, weight, next)
make_volume_list = _meep.make_volume_list

def _get_gradient(grad, fields_a, fields_f, grid_volume, frequencies, py_geom_list, f):
    return _meep._get_gradient(grad, fields_a, fields_f, grid_volume, frequencies, py_geom_list, f)
_get_gradient = _meep._get_gradient

def get_dft_flux_array(f, dft, c, num_freq):
    return _meep.get_dft_flux_array(f, dft, c, num_freq)
get_dft_flux_array = _meep.get_dft_flux_array

def get_dft_fields_array(f, dft, c, num_freq):
    return _meep.get_dft_fields_array(f, dft, c, num_freq)
get_dft_fields_array = _meep.get_dft_fields_array

def get_dft_force_array(f, dft, c, num_freq):
    return _meep.get_dft_force_array(f, dft, c, num_freq)
get_dft_force_array = _meep.get_dft_force_array

def get_dft_near2far_array(f, dft, c, num_freq):
    return _meep.get_dft_near2far_array(f, dft, c, num_freq)
get_dft_near2far_array = _meep.get_dft_near2far_array
class FragmentStatsVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FragmentStatsVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FragmentStatsVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.FragmentStatsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.FragmentStatsVector___nonzero__(self)

    def __bool__(self):
        return _meep.FragmentStatsVector___bool__(self)

    def __len__(self):
        return _meep.FragmentStatsVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.FragmentStatsVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.FragmentStatsVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.FragmentStatsVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.FragmentStatsVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.FragmentStatsVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.FragmentStatsVector___setitem__(self, *args)

    def pop(self):
        return _meep.FragmentStatsVector_pop(self)

    def append(self, x):
        return _meep.FragmentStatsVector_append(self, x)

    def empty(self):
        return _meep.FragmentStatsVector_empty(self)

    def size(self):
        return _meep.FragmentStatsVector_size(self)

    def swap(self, v):
        return _meep.FragmentStatsVector_swap(self, v)

    def begin(self):
        return _meep.FragmentStatsVector_begin(self)

    def end(self):
        return _meep.FragmentStatsVector_end(self)

    def rbegin(self):
        return _meep.FragmentStatsVector_rbegin(self)

    def rend(self):
        return _meep.FragmentStatsVector_rend(self)

    def clear(self):
        return _meep.FragmentStatsVector_clear(self)

    def get_allocator(self):
        return _meep.FragmentStatsVector_get_allocator(self)

    def pop_back(self):
        return _meep.FragmentStatsVector_pop_back(self)

    def erase(self, *args):
        return _meep.FragmentStatsVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_FragmentStatsVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.FragmentStatsVector_push_back(self, x)

    def front(self):
        return _meep.FragmentStatsVector_front(self)

    def back(self):
        return _meep.FragmentStatsVector_back(self)

    def assign(self, n, x):
        return _meep.FragmentStatsVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.FragmentStatsVector_resize(self, *args)

    def insert(self, *args):
        return _meep.FragmentStatsVector_insert(self, *args)

    def reserve(self, n):
        return _meep.FragmentStatsVector_reserve(self, n)

    def capacity(self):
        return _meep.FragmentStatsVector_capacity(self)
    __swig_destroy__ = _meep.delete_FragmentStatsVector
    __del__ = lambda self: None
FragmentStatsVector_swigregister = _meep.FragmentStatsVector_swigregister
FragmentStatsVector_swigregister(FragmentStatsVector)

class DftDataVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DftDataVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DftDataVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.DftDataVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.DftDataVector___nonzero__(self)

    def __bool__(self):
        return _meep.DftDataVector___bool__(self)

    def __len__(self):
        return _meep.DftDataVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.DftDataVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.DftDataVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.DftDataVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.DftDataVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.DftDataVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.DftDataVector___setitem__(self, *args)

    def pop(self):
        return _meep.DftDataVector_pop(self)

    def append(self, x):
        return _meep.DftDataVector_append(self, x)

    def empty(self):
        return _meep.DftDataVector_empty(self)

    def size(self):
        return _meep.DftDataVector_size(self)

    def swap(self, v):
        return _meep.DftDataVector_swap(self, v)

    def begin(self):
        return _meep.DftDataVector_begin(self)

    def end(self):
        return _meep.DftDataVector_end(self)

    def rbegin(self):
        return _meep.DftDataVector_rbegin(self)

    def rend(self):
        return _meep.DftDataVector_rend(self)

    def clear(self):
        return _meep.DftDataVector_clear(self)

    def get_allocator(self):
        return _meep.DftDataVector_get_allocator(self)

    def pop_back(self):
        return _meep.DftDataVector_pop_back(self)

    def erase(self, *args):
        return _meep.DftDataVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_DftDataVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.DftDataVector_push_back(self, x)

    def front(self):
        return _meep.DftDataVector_front(self)

    def back(self):
        return _meep.DftDataVector_back(self)

    def assign(self, n, x):
        return _meep.DftDataVector_assign(self, n, x)

    def insert(self, *args):
        return _meep.DftDataVector_insert(self, *args)

    def reserve(self, n):
        return _meep.DftDataVector_reserve(self, n)

    def capacity(self):
        return _meep.DftDataVector_capacity(self)
    __swig_destroy__ = _meep.delete_DftDataVector
    __del__ = lambda self: None
DftDataVector_swigregister = _meep.DftDataVector_swigregister
DftDataVector_swigregister(DftDataVector)

class VolumeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VolumeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VolumeVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.VolumeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.VolumeVector___nonzero__(self)

    def __bool__(self):
        return _meep.VolumeVector___bool__(self)

    def __len__(self):
        return _meep.VolumeVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.VolumeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.VolumeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.VolumeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.VolumeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.VolumeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.VolumeVector___setitem__(self, *args)

    def pop(self):
        return _meep.VolumeVector_pop(self)

    def append(self, x):
        return _meep.VolumeVector_append(self, x)

    def empty(self):
        return _meep.VolumeVector_empty(self)

    def size(self):
        return _meep.VolumeVector_size(self)

    def swap(self, v):
        return _meep.VolumeVector_swap(self, v)

    def begin(self):
        return _meep.VolumeVector_begin(self)

    def end(self):
        return _meep.VolumeVector_end(self)

    def rbegin(self):
        return _meep.VolumeVector_rbegin(self)

    def rend(self):
        return _meep.VolumeVector_rend(self)

    def clear(self):
        return _meep.VolumeVector_clear(self)

    def get_allocator(self):
        return _meep.VolumeVector_get_allocator(self)

    def pop_back(self):
        return _meep.VolumeVector_pop_back(self)

    def erase(self, *args):
        return _meep.VolumeVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_VolumeVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.VolumeVector_push_back(self, x)

    def front(self):
        return _meep.VolumeVector_front(self)

    def back(self):
        return _meep.VolumeVector_back(self)

    def assign(self, n, x):
        return _meep.VolumeVector_assign(self, n, x)

    def insert(self, *args):
        return _meep.VolumeVector_insert(self, *args)

    def reserve(self, n):
        return _meep.VolumeVector_reserve(self, n)

    def capacity(self):
        return _meep.VolumeVector_capacity(self)
    __swig_destroy__ = _meep.delete_VolumeVector
    __del__ = lambda self: None
VolumeVector_swigregister = _meep.VolumeVector_swigregister
VolumeVector_swigregister(VolumeVector)

class GridVolumeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GridVolumeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GridVolumeVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.GridVolumeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.GridVolumeVector___nonzero__(self)

    def __bool__(self):
        return _meep.GridVolumeVector___bool__(self)

    def __len__(self):
        return _meep.GridVolumeVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.GridVolumeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.GridVolumeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.GridVolumeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.GridVolumeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.GridVolumeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.GridVolumeVector___setitem__(self, *args)

    def pop(self):
        return _meep.GridVolumeVector_pop(self)

    def append(self, x):
        return _meep.GridVolumeVector_append(self, x)

    def empty(self):
        return _meep.GridVolumeVector_empty(self)

    def size(self):
        return _meep.GridVolumeVector_size(self)

    def swap(self, v):
        return _meep.GridVolumeVector_swap(self, v)

    def begin(self):
        return _meep.GridVolumeVector_begin(self)

    def end(self):
        return _meep.GridVolumeVector_end(self)

    def rbegin(self):
        return _meep.GridVolumeVector_rbegin(self)

    def rend(self):
        return _meep.GridVolumeVector_rend(self)

    def clear(self):
        return _meep.GridVolumeVector_clear(self)

    def get_allocator(self):
        return _meep.GridVolumeVector_get_allocator(self)

    def pop_back(self):
        return _meep.GridVolumeVector_pop_back(self)

    def erase(self, *args):
        return _meep.GridVolumeVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_GridVolumeVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.GridVolumeVector_push_back(self, x)

    def front(self):
        return _meep.GridVolumeVector_front(self)

    def back(self):
        return _meep.GridVolumeVector_back(self)

    def assign(self, n, x):
        return _meep.GridVolumeVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.GridVolumeVector_resize(self, *args)

    def insert(self, *args):
        return _meep.GridVolumeVector_insert(self, *args)

    def reserve(self, n):
        return _meep.GridVolumeVector_reserve(self, n)

    def capacity(self):
        return _meep.GridVolumeVector_capacity(self)
    __swig_destroy__ = _meep.delete_GridVolumeVector
    __del__ = lambda self: None
GridVolumeVector_swigregister = _meep.GridVolumeVector_swigregister
GridVolumeVector_swigregister(GridVolumeVector)

class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.IntVector___nonzero__(self)

    def __bool__(self):
        return _meep.IntVector___bool__(self)

    def __len__(self):
        return _meep.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.IntVector___setitem__(self, *args)

    def pop(self):
        return _meep.IntVector_pop(self)

    def append(self, x):
        return _meep.IntVector_append(self, x)

    def empty(self):
        return _meep.IntVector_empty(self)

    def size(self):
        return _meep.IntVector_size(self)

    def swap(self, v):
        return _meep.IntVector_swap(self, v)

    def begin(self):
        return _meep.IntVector_begin(self)

    def end(self):
        return _meep.IntVector_end(self)

    def rbegin(self):
        return _meep.IntVector_rbegin(self)

    def rend(self):
        return _meep.IntVector_rend(self)

    def clear(self):
        return _meep.IntVector_clear(self)

    def get_allocator(self):
        return _meep.IntVector_get_allocator(self)

    def pop_back(self):
        return _meep.IntVector_pop_back(self)

    def erase(self, *args):
        return _meep.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.IntVector_push_back(self, x)

    def front(self):
        return _meep.IntVector_front(self)

    def back(self):
        return _meep.IntVector_back(self)

    def assign(self, n, x):
        return _meep.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.IntVector_resize(self, *args)

    def insert(self, *args):
        return _meep.IntVector_insert(self, *args)

    def reserve(self, n):
        return _meep.IntVector_reserve(self, n)

    def capacity(self):
        return _meep.IntVector_capacity(self)
    __swig_destroy__ = _meep.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _meep.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _meep.DoubleVector___bool__(self)

    def __len__(self):
        return _meep.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _meep.DoubleVector_pop(self)

    def append(self, x):
        return _meep.DoubleVector_append(self, x)

    def empty(self):
        return _meep.DoubleVector_empty(self)

    def size(self):
        return _meep.DoubleVector_size(self)

    def swap(self, v):
        return _meep.DoubleVector_swap(self, v)

    def begin(self):
        return _meep.DoubleVector_begin(self)

    def end(self):
        return _meep.DoubleVector_end(self)

    def rbegin(self):
        return _meep.DoubleVector_rbegin(self)

    def rend(self):
        return _meep.DoubleVector_rend(self)

    def clear(self):
        return _meep.DoubleVector_clear(self)

    def get_allocator(self):
        return _meep.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _meep.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _meep.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.DoubleVector_push_back(self, x)

    def front(self):
        return _meep.DoubleVector_front(self)

    def back(self):
        return _meep.DoubleVector_back(self)

    def assign(self, n, x):
        return _meep.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _meep.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _meep.DoubleVector_reserve(self, n)

    def capacity(self):
        return _meep.DoubleVector_capacity(self)
    __swig_destroy__ = _meep.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _meep.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

Ex = _meep.Ex
Ey = _meep.Ey
Er = _meep.Er
Ep = _meep.Ep
Ez = _meep.Ez
Hx = _meep.Hx
Hy = _meep.Hy
Hr = _meep.Hr
Hp = _meep.Hp
Hz = _meep.Hz
Dx = _meep.Dx
Dy = _meep.Dy
Dr = _meep.Dr
Dp = _meep.Dp
Dz = _meep.Dz
Bx = _meep.Bx
By = _meep.By
Br = _meep.Br
Bp = _meep.Bp
Bz = _meep.Bz
Dielectric = _meep.Dielectric
Permeability = _meep.Permeability
NO_COMPONENT = _meep.NO_COMPONENT
Sx = _meep.Sx
Sy = _meep.Sy
Sr = _meep.Sr
Sp = _meep.Sp
Sz = _meep.Sz
EnergyDensity = _meep.EnergyDensity
D_EnergyDensity = _meep.D_EnergyDensity
H_EnergyDensity = _meep.H_EnergyDensity
D1 = _meep.D1
D2 = _meep.D2
D3 = _meep.D3
Dcyl = _meep.Dcyl
E_stuff = _meep.E_stuff
H_stuff = _meep.H_stuff
D_stuff = _meep.D_stuff
B_stuff = _meep.B_stuff
PE_stuff = _meep.PE_stuff
PH_stuff = _meep.PH_stuff
WE_stuff = _meep.WE_stuff
WH_stuff = _meep.WH_stuff
High = _meep.High
Low = _meep.Low
X = _meep.X
Y = _meep.Y
Z = _meep.Z
R = _meep.R
P = _meep.P
NO_DIRECTION = _meep.NO_DIRECTION
class signed_direction(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, signed_direction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, signed_direction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_signed_direction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __mul__(self, ph):
        return _meep.signed_direction___mul__(self, ph)

    def __eq__(self, sd):
        return _meep.signed_direction___eq__(self, sd)

    def __ne__(self, sd):
        return _meep.signed_direction___ne__(self, sd)
    __swig_setmethods__["d"] = _meep.signed_direction_d_set
    __swig_getmethods__["d"] = _meep.signed_direction_d_get
    if _newclass:
        d = _swig_property(_meep.signed_direction_d_get, _meep.signed_direction_d_set)
    __swig_setmethods__["flipped"] = _meep.signed_direction_flipped_set
    __swig_getmethods__["flipped"] = _meep.signed_direction_flipped_get
    if _newclass:
        flipped = _swig_property(_meep.signed_direction_flipped_get, _meep.signed_direction_flipped_set)
    __swig_setmethods__["phase"] = _meep.signed_direction_phase_set
    __swig_getmethods__["phase"] = _meep.signed_direction_phase_get
    if _newclass:
        phase = _swig_property(_meep.signed_direction_phase_get, _meep.signed_direction_phase_set)
    __swig_destroy__ = _meep.delete_signed_direction
    __del__ = lambda self: None
signed_direction_swigregister = _meep.signed_direction_swigregister
signed_direction_swigregister(signed_direction)
cvar = _meep.cvar
NUM_FIELD_COMPONENTS = cvar.NUM_FIELD_COMPONENTS
NUM_FIELD_TYPES = cvar.NUM_FIELD_TYPES


def number_of_directions(dim):
    return _meep.number_of_directions(dim)
number_of_directions = _meep.number_of_directions

def start_at_direction(dim):
    return _meep.start_at_direction(dim)
start_at_direction = _meep.start_at_direction

def stop_at_direction(dim):
    return _meep.stop_at_direction(dim)
stop_at_direction = _meep.stop_at_direction

def first_field_component(ft):
    return _meep.first_field_component(ft)
first_field_component = _meep.first_field_component

def flip(d):
    return _meep.flip(d)
flip = _meep.flip

def has_direction(dim, d):
    return _meep.has_direction(dim, d)
has_direction = _meep.has_direction

def has_field_direction(dim, d):
    return _meep.has_field_direction(dim, d)
has_field_direction = _meep.has_field_direction

def is_tm(c):
    return _meep.is_tm(c)
is_tm = _meep.is_tm

def abort(arg1):
    return _meep.abort(arg1)
abort = _meep.abort

def is_electric(c):
    return _meep.is_electric(c)
is_electric = _meep.is_electric

def is_magnetic(c):
    return _meep.is_magnetic(c)
is_magnetic = _meep.is_magnetic

def is_D(c):
    return _meep.is_D(c)
is_D = _meep.is_D

def is_B(c):
    return _meep.is_B(c)
is_B = _meep.is_B

def is_derived(c):
    return _meep.is_derived(c)
is_derived = _meep.is_derived

def is_poynting(c):
    return _meep.is_poynting(c)
is_poynting = _meep.is_poynting

def is_energydensity(c):
    return _meep.is_energydensity(c)
is_energydensity = _meep.is_energydensity

def meep_type(c):
    return _meep.meep_type(c)
meep_type = _meep.meep_type

def component_name(*args):
    return _meep.component_name(*args)
component_name = _meep.component_name

def direction_name(arg1):
    return _meep.direction_name(arg1)
direction_name = _meep.direction_name

def dimension_name(arg1):
    return _meep.dimension_name(arg1)
dimension_name = _meep.dimension_name

def component_index(c):
    return _meep.component_index(c)
component_index = _meep.component_index

def component_direction(*args):
    return _meep.component_direction(*args)
component_direction = _meep.component_direction

def direction_component(*args):
    return _meep.direction_component(*args)
direction_component = _meep.direction_component

def field_type_component(ft, c):
    return _meep.field_type_component(ft, c)
field_type_component = _meep.field_type_component

def coordinate_mismatch(*args):
    return _meep.coordinate_mismatch(*args)
coordinate_mismatch = _meep.coordinate_mismatch

def cycle_direction(dim, d, shift):
    return _meep.cycle_direction(dim, d, shift)
cycle_direction = _meep.cycle_direction

def cycle_component(dim, c, shift):
    return _meep.cycle_component(dim, c, shift)
cycle_component = _meep.cycle_component

def veccyl(rr, zz):
    return _meep.veccyl(rr, zz)
veccyl = _meep.veccyl

def zero_vec(arg1):
    return _meep.zero_vec(arg1)
zero_vec = _meep.zero_vec
class vec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vec, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _meep.delete_vec
    __del__ = lambda self: None

    def __add__(self, a):
        return _meep.vec___add__(self, a)

    def __iadd__(self, a):
        return _meep.vec___iadd__(self, a)

    def __sub__(self, a):
        return _meep.vec___sub__(self, a)

    def __neg__(self):
        return _meep.vec___neg__(self)

    def __isub__(self, a):
        return _meep.vec___isub__(self, a)

    def __ne__(self, a):
        return _meep.vec___ne__(self, a)

    def __eq__(self, a):
        return _meep.vec___eq__(self, a)

    def round_float(self):
        return _meep.vec_round_float(self)

    def __mul__(self, s):
        return _meep.vec___mul__(self, s)

    def __truediv__(self, *args):
        return _meep.vec___truediv__(self, *args)
    __div__ = __truediv__



    def __and__(self, a):
        return _meep.vec___and__(self, a)
    __swig_setmethods__["dim"] = _meep.vec_dim_set
    __swig_getmethods__["dim"] = _meep.vec_dim_get
    if _newclass:
        dim = _swig_property(_meep.vec_dim_get, _meep.vec_dim_set)

    def r(self):
        return _meep.vec_r(self)

    def x(self):
        return _meep.vec_x(self)

    def y(self):
        return _meep.vec_y(self)

    def z(self):
        return _meep.vec_z(self)

    def in_direction(self, d):
        return _meep.vec_in_direction(self, d)

    def set_direction(self, d, val):
        return _meep.vec_set_direction(self, d, val)

    def project_to_boundary(self, arg2, boundary_loc):
        return _meep.vec_project_to_boundary(self, arg2, boundary_loc)

    def __repr__(self):
        return _meep.vec___repr__(self)
vec_swigregister = _meep.vec_swigregister
vec_swigregister(vec)

def vec_dim(di):
    val = _meep.new_vec_dim(di)
    return val

def vec_dim_val(di, val):
    val = _meep.new_vec_dim_val(di, val)
    return val

def _vec(*args):
    val = _meep.new__vec(*args)
    return val


def vec_abs(pt):
    return _meep.vec_abs(pt)
vec_abs = _meep.vec_abs

def one_vec(di):
    return _meep.one_vec(di)
one_vec = _meep.one_vec

def unit_vec(di, d):
    return _meep.unit_vec(di, d)
unit_vec = _meep.unit_vec

def clean_vec(pt, val_unused=0.0):
    return _meep.clean_vec(pt, val_unused)
clean_vec = _meep.clean_vec

def iveccyl(xx, yy):
    return _meep.iveccyl(xx, yy)
iveccyl = _meep.iveccyl

def zero_ivec(arg1):
    return _meep.zero_ivec(arg1)
zero_ivec = _meep.zero_ivec

def one_ivec(arg1):
    return _meep.one_ivec(arg1)
one_ivec = _meep.one_ivec
class ivec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ivec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ivec, name)

    def __init__(self, *args):
        this = _meep.new_ivec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_ivec
    __del__ = lambda self: None

    def yucky_val(self, arg2):
        return _meep.ivec_yucky_val(self, arg2)

    def __add__(self, a):
        return _meep.ivec___add__(self, a)

    def __iadd__(self, a):
        return _meep.ivec___iadd__(self, a)

    def __sub__(self, a):
        return _meep.ivec___sub__(self, a)

    def __neg__(self):
        return _meep.ivec___neg__(self)

    def __isub__(self, a):
        return _meep.ivec___isub__(self, a)

    def __ne__(self, a):
        return _meep.ivec___ne__(self, a)

    def __eq__(self, a):
        return _meep.ivec___eq__(self, a)

    def __le__(self, a):
        return _meep.ivec___le__(self, a)

    def __ge__(self, a):
        return _meep.ivec___ge__(self, a)

    def __lt__(self, a):
        return _meep.ivec___lt__(self, a)

    def __gt__(self, a):
        return _meep.ivec___gt__(self, a)

    def __mul__(self, *args):
        return _meep.ivec___mul__(self, *args)
    __swig_setmethods__["dim"] = _meep.ivec_dim_set
    __swig_getmethods__["dim"] = _meep.ivec_dim_get
    if _newclass:
        dim = _swig_property(_meep.ivec_dim_get, _meep.ivec_dim_set)

    def r(self):
        return _meep.ivec_r(self)

    def x(self):
        return _meep.ivec_x(self)

    def y(self):
        return _meep.ivec_y(self)

    def z(self):
        return _meep.ivec_z(self)

    def in_direction(self, d):
        return _meep.ivec_in_direction(self, d)

    def set_direction(self, d, val):
        return _meep.ivec_set_direction(self, d, val)

    def round_up_to_even(self):
        return _meep.ivec_round_up_to_even(self)

    def __repr__(self):
        return _meep.ivec___repr__(self)
ivec_swigregister = _meep.ivec_swigregister
ivec_swigregister(ivec)


def unit_ivec(di, d):
    return _meep.unit_ivec(di, d)
unit_ivec = _meep.unit_ivec

def vec_max(*args):
    return _meep.vec_max(*args)
vec_max = _meep.vec_max

def vec_min(*args):
    return _meep.vec_min(*args)
vec_min = _meep.vec_min
class volume(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, volume, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, volume, name)
    __swig_setmethods__["dim"] = _meep.volume_dim_set
    __swig_getmethods__["dim"] = _meep.volume_dim_get
    if _newclass:
        dim = _swig_property(_meep.volume_dim_get, _meep.volume_dim_set)

    def __init__(self, *args):
        this = _meep.new_volume(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_direction_min(self, d, val):
        return _meep.volume_set_direction_min(self, d, val)

    def set_direction_max(self, d, val):
        return _meep.volume_set_direction_max(self, d, val)

    def in_direction_min(self, d):
        return _meep.volume_in_direction_min(self, d)

    def in_direction_max(self, d):
        return _meep.volume_in_direction_max(self, d)

    def in_direction(self, d):
        return _meep.volume_in_direction(self, d)

    def computational_volume(self):
        return _meep.volume_computational_volume(self)

    def integral_volume(self):
        return _meep.volume_integral_volume(self)

    def full_volume(self):
        return _meep.volume_full_volume(self)

    def center(self):
        return _meep.volume_center(self)

    def diameter(self):
        return _meep.volume_diameter(self)

    def contains(self, *args):
        return _meep.volume_contains(self, *args)

    def intersect_with(self, a):
        return _meep.volume_intersect_with(self, a)

    def __and__(self, a):
        return _meep.volume___and__(self, a)

    def __or__(self, a):
        return _meep.volume___or__(self, a)

    def __add__(self, a):
        return _meep.volume___add__(self, a)

    def __iadd__(self, a):
        return _meep.volume___iadd__(self, a)

    def __sub__(self, a):
        return _meep.volume___sub__(self, a)

    def __isub__(self, a):
        return _meep.volume___isub__(self, a)

    def __eq__(self, a):
        return _meep.volume___eq__(self, a)

    def __ne__(self, a):
        return _meep.volume___ne__(self, a)

    def round_float(self):
        return _meep.volume_round_float(self)

    def intersects(self, a):
        return _meep.volume_intersects(self, a)

    def __contains__(self, a):
        return _meep.volume___contains__(self, a)

    def get_min_corner(self):
        return _meep.volume_get_min_corner(self)

    def get_max_corner(self):
        return _meep.volume_get_max_corner(self)

    def normal_direction(self):
        return _meep.volume_normal_direction(self)

    def __repr__(self):
        return _meep.volume___repr__(self)
    __swig_destroy__ = _meep.delete_volume
    __del__ = lambda self: None
volume_swigregister = _meep.volume_swigregister
volume_swigregister(volume)


def volcyl(rsize, zsize, a):
    return _meep.volcyl(rsize, zsize, a)
volcyl = _meep.volcyl

def volone(zsize, a):
    return _meep.volone(zsize, a)
volone = _meep.volone

def vol1d(zsize, a):
    return _meep.vol1d(zsize, a)
vol1d = _meep.vol1d

def voltwo(xsize, ysize, a):
    return _meep.voltwo(xsize, ysize, a)
voltwo = _meep.voltwo

def vol2d(xsize, ysize, a):
    return _meep.vol2d(xsize, ysize, a)
vol2d = _meep.vol2d

def vol3d(xsize, ysize, zsize, a):
    return _meep.vol3d(xsize, ysize, zsize, a)
vol3d = _meep.vol3d
class grid_volume(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, grid_volume, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, grid_volume, name)

    def __init__(self):
        this = _meep.new_grid_volume()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def subvolume(self, arg2, ie):
        return _meep.grid_volume_subvolume(self, arg2, ie)

    def init_subvolume(self, arg2, ie):
        return _meep.grid_volume_init_subvolume(self, arg2, ie)
    __swig_setmethods__["dim"] = _meep.grid_volume_dim_set
    __swig_getmethods__["dim"] = _meep.grid_volume_dim_get
    if _newclass:
        dim = _swig_property(_meep.grid_volume_dim_get, _meep.grid_volume_dim_set)
    __swig_setmethods__["a"] = _meep.grid_volume_a_set
    __swig_getmethods__["a"] = _meep.grid_volume_a_get
    if _newclass:
        a = _swig_property(_meep.grid_volume_a_get, _meep.grid_volume_a_set)
    __swig_setmethods__["inva"] = _meep.grid_volume_inva_set
    __swig_getmethods__["inva"] = _meep.grid_volume_inva_get
    if _newclass:
        inva = _swig_property(_meep.grid_volume_inva_get, _meep.grid_volume_inva_set)

    def print_grid_volume(self):
        return _meep.grid_volume_print_grid_volume(self)

    def stride(self, d):
        return _meep.grid_volume_stride(self, d)

    def num_direction(self, d):
        return _meep.grid_volume_num_direction(self, d)

    def yucky_num(self, arg2):
        return _meep.grid_volume_yucky_num(self, arg2)

    def yucky_direction(self, arg2):
        return _meep.grid_volume_yucky_direction(self, arg2)

    def set_num_direction(self, d, value):
        return _meep.grid_volume_set_num_direction(self, d, value)

    def nr(self):
        return _meep.grid_volume_nr(self)

    def nx(self):
        return _meep.grid_volume_nx(self)

    def ny(self):
        return _meep.grid_volume_ny(self)

    def nz(self):
        return _meep.grid_volume_nz(self)

    def has_field(self, c):
        return _meep.grid_volume_has_field(self, c)

    def has_boundary(self, arg2, arg3):
        return _meep.grid_volume_has_boundary(self, arg2, arg3)

    def dr(self):
        return _meep.grid_volume_dr(self)

    def dx(self):
        return _meep.grid_volume_dx(self)

    def dy(self):
        return _meep.grid_volume_dy(self)

    def dz(self):
        return _meep.grid_volume_dz(self)

    def ntot(self):
        return _meep.grid_volume_ntot(self)

    def nowned_min(self):
        return _meep.grid_volume_nowned_min(self)

    def nowned(self, c):
        return _meep.grid_volume_nowned(self, c)

    def __getitem__(self, p):
        return _meep.grid_volume___getitem__(self, p)

    def index(self, arg2, arg3):
        return _meep.grid_volume_index(self, arg2, arg3)

    def round_vec(self, arg2):
        return _meep.grid_volume_round_vec(self, arg2)

    def interpolate(self, *args):
        return _meep.grid_volume_interpolate(self, *args)

    def dV(self, *args):
        return _meep.grid_volume_dV(self, *args)

    def intersect_with(self, vol_in, intersection=None, others=None, num_others=None):
        return _meep.grid_volume_intersect_with(self, vol_in, intersection, others, num_others)

    def rmin(self):
        return _meep.grid_volume_rmin(self)

    def rmax(self):
        return _meep.grid_volume_rmax(self)

    def xmin(self):
        return _meep.grid_volume_xmin(self)

    def xmax(self):
        return _meep.grid_volume_xmax(self)

    def ymin(self):
        return _meep.grid_volume_ymin(self)

    def ymax(self):
        return _meep.grid_volume_ymax(self)

    def zmin(self):
        return _meep.grid_volume_zmin(self)

    def zmax(self):
        return _meep.grid_volume_zmax(self)

    def center(self):
        return _meep.grid_volume_center(self)

    def icenter(self):
        return _meep.grid_volume_icenter(self)

    def loc(self, arg2, index):
        return _meep.grid_volume_loc(self, arg2, index)

    def loc_at_resolution(self, index, res):
        return _meep.grid_volume_loc_at_resolution(self, index, res)

    def ntot_at_resolution(self, res):
        return _meep.grid_volume_ntot_at_resolution(self, res)

    def iloc(self, arg2, index):
        return _meep.grid_volume_iloc(self, arg2, index)

    def surface_area(self):
        return _meep.grid_volume_surface_area(self)

    def yee_index(self, c):
        return _meep.grid_volume_yee_index(self, c)

    def yee_shift(self, arg2):
        return _meep.grid_volume_yee_shift(self, arg2)

    def eps_component(self):
        return _meep.grid_volume_eps_component(self)

    def yee2cent_offsets(self, c, offset1, offset2):
        return _meep.grid_volume_yee2cent_offsets(self, c, offset1, offset2)

    def cent2yee_offsets(self, c, offset1, offset2):
        return _meep.grid_volume_cent2yee_offsets(self, c, offset1, offset2)

    def boundary_location(self, arg2, arg3):
        return _meep.grid_volume_boundary_location(self, arg2, arg3)

    def big_corner(self):
        return _meep.grid_volume_big_corner(self)

    def little_corner(self):
        return _meep.grid_volume_little_corner(self)

    def corner(self, b):
        return _meep.grid_volume_corner(self, b)

    def contains(self, *args):
        return _meep.grid_volume_contains(self, *args)

    def little_owned_corner0(self, c):
        return _meep.grid_volume_little_owned_corner0(self, c)

    def little_owned_corner(self, c):
        return _meep.grid_volume_little_owned_corner(self, c)

    def owns(self, arg2):
        return _meep.grid_volume_owns(self, arg2)

    def surroundings(self):
        return _meep.grid_volume_surroundings(self)

    def interior(self):
        return _meep.grid_volume_interior(self)

    def get_boundary_icorners(self, c, ib, cs, ce):
        return _meep.grid_volume_get_boundary_icorners(self, c, ib, cs, ce)

    def split(self, num, which):
        return _meep.grid_volume_split(self, num, which)

    def split_by_effort(self, num, which, Ngv=0, v=None, effort=None):
        return _meep.grid_volume_split_by_effort(self, num, which, Ngv, v, effort)

    def split_into_n(self, n):
        return _meep.grid_volume_split_into_n(self, n)

    def split_at_fraction(self, want_high, numer, bestd=-1, bestlen=1):
        return _meep.grid_volume_split_at_fraction(self, want_high, numer, bestd, bestlen)

    def get_cost(self):
        return _meep.grid_volume_get_cost(self)

    def halve(self, d):
        return _meep.grid_volume_halve(self, d)

    def pad_self(self, d):
        return _meep.grid_volume_pad_self(self, d)

    def pad(self, *args):
        return _meep.grid_volume_pad(self, *args)

    def iyee_shift(self, c):
        return _meep.grid_volume_iyee_shift(self, c)

    def get_origin(self):
        return _meep.grid_volume_get_origin(self)

    def shift_origin(self, *args):
        return _meep.grid_volume_shift_origin(self, *args)

    def set_origin(self, *args):
        return _meep.grid_volume_set_origin(self, *args)

    def center_origin(self):
        return _meep.grid_volume_center_origin(self)

    def origin_in_direction(self, d):
        return _meep.grid_volume_origin_in_direction(self, d)

    def iorigin_in_direction(self, d):
        return _meep.grid_volume_iorigin_in_direction(self, d)

    def origin_r(self):
        return _meep.grid_volume_origin_r(self)

    def origin_x(self):
        return _meep.grid_volume_origin_x(self)

    def origin_y(self):
        return _meep.grid_volume_origin_y(self)

    def origin_z(self):
        return _meep.grid_volume_origin_z(self)

    def __repr__(self):
        return _meep.grid_volume___repr__(self)
    __swig_destroy__ = _meep.delete_grid_volume
    __del__ = lambda self: None
grid_volume_swigregister = _meep.grid_volume_swigregister
grid_volume_swigregister(grid_volume)


def identity():
    return _meep.identity()
identity = _meep.identity

def rotate4(arg1, arg2):
    return _meep.rotate4(arg1, arg2)
rotate4 = _meep.rotate4

def rotate2(arg1, arg2):
    return _meep.rotate2(arg1, arg2)
rotate2 = _meep.rotate2

def mirror(arg1, arg2):
    return _meep.mirror(arg1, arg2)
mirror = _meep.mirror

def r_to_minus_r_symmetry(m):
    return _meep.r_to_minus_r_symmetry(m)
r_to_minus_r_symmetry = _meep.r_to_minus_r_symmetry
class symmetry(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, symmetry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, symmetry, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_symmetry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_symmetry
    __del__ = lambda self: None

    def transform_unshifted(self, arg2, n):
        return _meep.symmetry_transform_unshifted(self, arg2, n)

    def transform(self, *args):
        return _meep.symmetry_transform(self, *args)

    def phase_shift(self, *args):
        return _meep.symmetry_phase_shift(self, *args)

    def multiplicity(self):
        return _meep.symmetry_multiplicity(self)

    def is_primitive(self, arg2):
        return _meep.symmetry_is_primitive(self, arg2)

    def symmetry_reduce(self, gl):
        return _meep.symmetry_symmetry_reduce(self, gl)

    def __add__(self, arg2):
        return _meep.symmetry___add__(self, arg2)

    def __mul__(self, arg2):
        return _meep.symmetry___mul__(self, arg2)

    def __sub__(self, b):
        return _meep.symmetry___sub__(self, b)

    def __neg__(self):
        return _meep.symmetry___neg__(self)

    def symmetry_assign(self, arg2):
        return _meep.symmetry_symmetry_assign(self, arg2)

    def __eq__(self, arg2):
        return _meep.symmetry___eq__(self, arg2)

    def __ne__(self, S):
        return _meep.symmetry___ne__(self, S)
symmetry_swigregister = _meep.symmetry_swigregister
symmetry_swigregister(symmetry)

class volume_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, volume_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, volume_list, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _meep.delete_volume_list
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _meep.new_volume_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["v"] = _meep.volume_list_v_set
    __swig_getmethods__["v"] = _meep.volume_list_v_get
    if _newclass:
        v = _swig_property(_meep.volume_list_v_get, _meep.volume_list_v_set)
    __swig_setmethods__["c"] = _meep.volume_list_c_set
    __swig_getmethods__["c"] = _meep.volume_list_c_get
    if _newclass:
        c = _swig_property(_meep.volume_list_c_get, _meep.volume_list_c_set)
    __swig_setmethods__["weight"] = _meep.volume_list_weight_set
    __swig_getmethods__["weight"] = _meep.volume_list_weight_get
    if _newclass:
        weight = _swig_property(_meep.volume_list_weight_get, _meep.volume_list_weight_set)
    __swig_setmethods__["next"] = _meep.volume_list_next_set
    __swig_getmethods__["next"] = _meep.volume_list_next_get
    if _newclass:
        next = _swig_property(_meep.volume_list_next_get, _meep.volume_list_next_set)
volume_list_swigregister = _meep.volume_list_swigregister
volume_list_swigregister(volume_list)

MEEP_SINGLE = _meep.MEEP_SINGLE
MEEP_MIN_OUTPUT_TIME = _meep.MEEP_MIN_OUTPUT_TIME

def matrix_invert(Vinv, V):
    return _meep.matrix_invert(Vinv, V)
matrix_invert = _meep.matrix_invert

def linspace(freq_min, freq_max, Nfreq):
    return _meep.linspace(freq_min, freq_max, Nfreq)
linspace = _meep.linspace

def pml_quadratic_profile(arg1, arg2):
    return _meep.pml_quadratic_profile(arg1, arg2)
pml_quadratic_profile = _meep.pml_quadratic_profile
class susceptibility(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, susceptibility, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, susceptibility, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_susceptibility(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        return _meep.susceptibility_clone(self)
    __swig_destroy__ = _meep.delete_susceptibility
    __del__ = lambda self: None

    def get_id(self):
        return _meep.susceptibility_get_id(self)

    def __eq__(self, s):
        return _meep.susceptibility___eq__(self, s)

    def chi1(self, freq, sigma=1):
        return _meep.susceptibility_chi1(self, freq, sigma)

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def needs_P(self, c, cmp, W):
        return _meep.susceptibility_needs_P(self, c, cmp, W)

    def needs_W_notowned(self, c, W):
        return _meep.susceptibility_needs_W_notowned(self, c, W)

    def needs_W_prev(self):
        return _meep.susceptibility_needs_W_prev(self)

    def new_internal_data(self, W, gv):
        return _meep.susceptibility_new_internal_data(self, W, gv)

    def delete_internal_data(self, data):
        return _meep.susceptibility_delete_internal_data(self, data)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.susceptibility_copy_internal_data(self, data)

    def num_internal_notowned_needed(self, c, P_internal_data):
        return _meep.susceptibility_num_internal_notowned_needed(self, c, P_internal_data)

    def internal_notowned_ptr(self, inotowned, c, n, P_internal_data):
        return _meep.susceptibility_internal_notowned_ptr(self, inotowned, c, n, P_internal_data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)

    def dump_params(self, h5f, start):
        return _meep.susceptibility_dump_params(self, h5f, start)

    def get_num_params(self):
        return _meep.susceptibility_get_num_params(self)

    def set_id(self, new_id):
        return _meep.susceptibility_set_id(self, new_id)
    __swig_setmethods__["next"] = _meep.susceptibility_next_set
    __swig_getmethods__["next"] = _meep.susceptibility_next_get
    if _newclass:
        next = _swig_property(_meep.susceptibility_next_get, _meep.susceptibility_next_set)
    __swig_setmethods__["ntot"] = _meep.susceptibility_ntot_set
    __swig_getmethods__["ntot"] = _meep.susceptibility_ntot_get
    if _newclass:
        ntot = _swig_property(_meep.susceptibility_ntot_get, _meep.susceptibility_ntot_set)
    __swig_setmethods__["sigma"] = _meep.susceptibility_sigma_set
    __swig_getmethods__["sigma"] = _meep.susceptibility_sigma_get
    if _newclass:
        sigma = _swig_property(_meep.susceptibility_sigma_get, _meep.susceptibility_sigma_set)
    __swig_setmethods__["trivial_sigma"] = _meep.susceptibility_trivial_sigma_set
    __swig_getmethods__["trivial_sigma"] = _meep.susceptibility_trivial_sigma_get
    if _newclass:
        trivial_sigma = _swig_property(_meep.susceptibility_trivial_sigma_get, _meep.susceptibility_trivial_sigma_set)
susceptibility_swigregister = _meep.susceptibility_swigregister
susceptibility_swigregister(susceptibility)
pi = cvar.pi
nan = cvar.nan

class lorentzian_susceptibility(susceptibility):
    __swig_setmethods__ = {}
    for _s in [susceptibility]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, lorentzian_susceptibility, name, value)
    __swig_getmethods__ = {}
    for _s in [susceptibility]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, lorentzian_susceptibility, name)
    __repr__ = _swig_repr

    def __init__(self, omega_0, gamma, no_omega_0_denominator=False):
        this = _meep.new_lorentzian_susceptibility(omega_0, gamma, no_omega_0_denominator)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        return _meep.lorentzian_susceptibility_clone(self)
    __swig_destroy__ = _meep.delete_lorentzian_susceptibility
    __del__ = lambda self: None

    def chi1(self, freq, sigma=1):
        return _meep.lorentzian_susceptibility_chi1(self, freq, sigma)

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.lorentzian_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.lorentzian_susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def new_internal_data(self, W, gv):
        return _meep.lorentzian_susceptibility_new_internal_data(self, W, gv)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.lorentzian_susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.lorentzian_susceptibility_copy_internal_data(self, data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.lorentzian_susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.lorentzian_susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)

    def dump_params(self, h5f, start):
        return _meep.lorentzian_susceptibility_dump_params(self, h5f, start)

    def get_num_params(self):
        return _meep.lorentzian_susceptibility_get_num_params(self)
lorentzian_susceptibility_swigregister = _meep.lorentzian_susceptibility_swigregister
lorentzian_susceptibility_swigregister(lorentzian_susceptibility)

class noisy_lorentzian_susceptibility(lorentzian_susceptibility):
    __swig_setmethods__ = {}
    for _s in [lorentzian_susceptibility]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, noisy_lorentzian_susceptibility, name, value)
    __swig_getmethods__ = {}
    for _s in [lorentzian_susceptibility]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, noisy_lorentzian_susceptibility, name)
    __repr__ = _swig_repr

    def __init__(self, noise_amp, omega_0, gamma, no_omega_0_denominator=False):
        this = _meep.new_noisy_lorentzian_susceptibility(noise_amp, omega_0, gamma, no_omega_0_denominator)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        return _meep.noisy_lorentzian_susceptibility_clone(self)

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.noisy_lorentzian_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def dump_params(self, h5f, start):
        return _meep.noisy_lorentzian_susceptibility_dump_params(self, h5f, start)

    def get_num_params(self):
        return _meep.noisy_lorentzian_susceptibility_get_num_params(self)
    __swig_destroy__ = _meep.delete_noisy_lorentzian_susceptibility
    __del__ = lambda self: None
noisy_lorentzian_susceptibility_swigregister = _meep.noisy_lorentzian_susceptibility_swigregister
noisy_lorentzian_susceptibility_swigregister(noisy_lorentzian_susceptibility)

GYROTROPIC_LORENTZIAN = _meep.GYROTROPIC_LORENTZIAN
GYROTROPIC_DRUDE = _meep.GYROTROPIC_DRUDE
GYROTROPIC_SATURATED = _meep.GYROTROPIC_SATURATED
class gyrotropic_susceptibility(susceptibility):
    __swig_setmethods__ = {}
    for _s in [susceptibility]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, gyrotropic_susceptibility, name, value)
    __swig_getmethods__ = {}
    for _s in [susceptibility]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, gyrotropic_susceptibility, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_gyrotropic_susceptibility(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        return _meep.gyrotropic_susceptibility_clone(self)

    def new_internal_data(self, W, gv):
        return _meep.gyrotropic_susceptibility_new_internal_data(self, W, gv)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.gyrotropic_susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.gyrotropic_susceptibility_copy_internal_data(self, data)

    def needs_P(self, c, cmp, W):
        return _meep.gyrotropic_susceptibility_needs_P(self, c, cmp, W)

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.gyrotropic_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.gyrotropic_susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.gyrotropic_susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.gyrotropic_susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)

    def dump_params(self, h5f, start):
        return _meep.gyrotropic_susceptibility_dump_params(self, h5f, start)

    def get_num_params(self):
        return _meep.gyrotropic_susceptibility_get_num_params(self)

    def needs_W_notowned(self, c, W):
        return _meep.gyrotropic_susceptibility_needs_W_notowned(self, c, W)
    __swig_destroy__ = _meep.delete_gyrotropic_susceptibility
    __del__ = lambda self: None
gyrotropic_susceptibility_swigregister = _meep.gyrotropic_susceptibility_swigregister
gyrotropic_susceptibility_swigregister(gyrotropic_susceptibility)

class multilevel_susceptibility(susceptibility):
    __swig_setmethods__ = {}
    for _s in [susceptibility]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, multilevel_susceptibility, name, value)
    __swig_getmethods__ = {}
    for _s in [susceptibility]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, multilevel_susceptibility, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_multilevel_susceptibility(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        return _meep.multilevel_susceptibility_clone(self)
    __swig_destroy__ = _meep.delete_multilevel_susceptibility
    __del__ = lambda self: None

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.multilevel_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.multilevel_susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def new_internal_data(self, W, gv):
        return _meep.multilevel_susceptibility_new_internal_data(self, W, gv)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.multilevel_susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.multilevel_susceptibility_copy_internal_data(self, data)

    def delete_internal_data(self, data):
        return _meep.multilevel_susceptibility_delete_internal_data(self, data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.multilevel_susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.multilevel_susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)

    def needs_W_notowned(self, c, W):
        return _meep.multilevel_susceptibility_needs_W_notowned(self, c, W)

    def needs_W_prev(self):
        return _meep.multilevel_susceptibility_needs_W_prev(self)
multilevel_susceptibility_swigregister = _meep.multilevel_susceptibility_swigregister
multilevel_susceptibility_swigregister(multilevel_susceptibility)

class h5file(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, h5file, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, h5file, name)
    __repr__ = _swig_repr
    READONLY = _meep.h5file_READONLY
    READWRITE = _meep.h5file_READWRITE
    WRITE = _meep.h5file_WRITE

    def __init__(self, *args):
        this = _meep.new_h5file(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_h5file
    __del__ = lambda self: None

    def ok(self):
        return _meep.h5file_ok(self)

    def read(self, *args):
        return _meep.h5file_read(self, *args)

    def write(self, *args):
        return _meep.h5file_write(self, *args)

    def create_data(self, dataname, rank, dims, append_data=False, single_precision=True):
        return _meep.h5file_create_data(self, dataname, rank, dims, append_data, single_precision)

    def extend_data(self, dataname, rank, dims):
        return _meep.h5file_extend_data(self, dataname, rank, dims)

    def create_or_extend_data(self, dataname, rank, dims, append_data, single_precision):
        return _meep.h5file_create_or_extend_data(self, dataname, rank, dims, append_data, single_precision)

    def write_chunk(self, *args):
        return _meep.h5file_write_chunk(self, *args)

    def done_writing_chunks(self):
        return _meep.h5file_done_writing_chunks(self)

    def read_size(self, dataname, rank, dims, maxrank):
        return _meep.h5file_read_size(self, dataname, rank, dims, maxrank)

    def read_chunk(self, *args):
        return _meep.h5file_read_chunk(self, *args)

    def remove(self):
        return _meep.h5file_remove(self)

    def remove_data(self, dataname):
        return _meep.h5file_remove_data(self, dataname)

    def file_name(self):
        return _meep.h5file_file_name(self)

    def prevent_deadlock(self):
        return _meep.h5file_prevent_deadlock(self)

    def dataset_exists(self, name):
        return _meep.h5file_dataset_exists(self, name)
    __swig_setmethods__["extending"] = _meep.h5file_extending_set
    __swig_getmethods__["extending"] = _meep.h5file_extending_get
    if _newclass:
        extending = _swig_property(_meep.h5file_extending_get, _meep.h5file_extending_set)

    def get_extending(self, dataname):
        return _meep.h5file_get_extending(self, dataname)
h5file_swigregister = _meep.h5file_swigregister
h5file_swigregister(h5file)

DEFAULT_SUBPIXEL_TOL = _meep.DEFAULT_SUBPIXEL_TOL
DEFAULT_SUBPIXEL_MAXEVAL = _meep.DEFAULT_SUBPIXEL_MAXEVAL
class material_function(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, material_function, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, material_function, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _meep.new_material_function()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_material_function
    __del__ = lambda self: None

    def set_volume(self, v):
        return _meep.material_function_set_volume(self, v)

    def unset_volume(self):
        return _meep.material_function_unset_volume(self)

    def chi1p1(self, ft, r):
        return _meep.material_function_chi1p1(self, ft, r)

    def eps(self, r):
        return _meep.material_function_eps(self, r)

    def has_mu(self):
        return _meep.material_function_has_mu(self)

    def mu(self, r):
        return _meep.material_function_mu(self, r)

    def has_conductivity(self, c):
        return _meep.material_function_has_conductivity(self, c)

    def conductivity(self, c, r):
        return _meep.material_function_conductivity(self, c, r)

    def normal_vector(self, ft, v):
        return _meep.material_function_normal_vector(self, ft, v)

    def eff_chi1inv_row(self, c, chi1inv_row, v, tol=1e-4, maxeval=100000):
        return _meep.material_function_eff_chi1inv_row(self, c, chi1inv_row, v, tol, maxeval)

    def sigma_row(self, c, sigrow, r):
        return _meep.material_function_sigma_row(self, c, sigrow, r)

    def has_chi3(self, c):
        return _meep.material_function_has_chi3(self, c)

    def chi3(self, c, r):
        return _meep.material_function_chi3(self, c, r)

    def has_chi2(self, c):
        return _meep.material_function_has_chi2(self, c)

    def chi2(self, c, r):
        return _meep.material_function_chi2(self, c, r)
material_function_swigregister = _meep.material_function_swigregister
material_function_swigregister(material_function)

class simple_material_function(material_function):
    __swig_setmethods__ = {}
    for _s in [material_function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, simple_material_function, name, value)
    __swig_getmethods__ = {}
    for _s in [material_function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, simple_material_function, name)
    __repr__ = _swig_repr

    def __init__(self, func):
        this = _meep.new_simple_material_function(func)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_simple_material_function
    __del__ = lambda self: None

    def chi1p1(self, ft, r):
        return _meep.simple_material_function_chi1p1(self, ft, r)

    def eps(self, r):
        return _meep.simple_material_function_eps(self, r)

    def mu(self, r):
        return _meep.simple_material_function_mu(self, r)

    def conductivity(self, c, r):
        return _meep.simple_material_function_conductivity(self, c, r)

    def sigma_row(self, c, sigrow, r):
        return _meep.simple_material_function_sigma_row(self, c, sigrow, r)

    def chi3(self, c, r):
        return _meep.simple_material_function_chi3(self, c, r)

    def chi2(self, c, r):
        return _meep.simple_material_function_chi2(self, c, r)
simple_material_function_swigregister = _meep.simple_material_function_swigregister
simple_material_function_swigregister(simple_material_function)

class structure_chunk(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, structure_chunk, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, structure_chunk, name)
    __repr__ = _swig_repr
    __swig_setmethods__["a"] = _meep.structure_chunk_a_set
    __swig_getmethods__["a"] = _meep.structure_chunk_a_get
    if _newclass:
        a = _swig_property(_meep.structure_chunk_a_get, _meep.structure_chunk_a_set)
    __swig_setmethods__["Courant"] = _meep.structure_chunk_Courant_set
    __swig_getmethods__["Courant"] = _meep.structure_chunk_Courant_get
    if _newclass:
        Courant = _swig_property(_meep.structure_chunk_Courant_get, _meep.structure_chunk_Courant_set)
    __swig_setmethods__["dt"] = _meep.structure_chunk_dt_set
    __swig_getmethods__["dt"] = _meep.structure_chunk_dt_get
    if _newclass:
        dt = _swig_property(_meep.structure_chunk_dt_get, _meep.structure_chunk_dt_set)
    __swig_setmethods__["chi3"] = _meep.structure_chunk_chi3_set
    __swig_getmethods__["chi3"] = _meep.structure_chunk_chi3_get
    if _newclass:
        chi3 = _swig_property(_meep.structure_chunk_chi3_get, _meep.structure_chunk_chi3_set)
    __swig_setmethods__["chi2"] = _meep.structure_chunk_chi2_set
    __swig_getmethods__["chi2"] = _meep.structure_chunk_chi2_get
    if _newclass:
        chi2 = _swig_property(_meep.structure_chunk_chi2_get, _meep.structure_chunk_chi2_set)
    __swig_setmethods__["chi1inv"] = _meep.structure_chunk_chi1inv_set
    __swig_getmethods__["chi1inv"] = _meep.structure_chunk_chi1inv_get
    if _newclass:
        chi1inv = _swig_property(_meep.structure_chunk_chi1inv_get, _meep.structure_chunk_chi1inv_set)
    __swig_setmethods__["trivial_chi1inv"] = _meep.structure_chunk_trivial_chi1inv_set
    __swig_getmethods__["trivial_chi1inv"] = _meep.structure_chunk_trivial_chi1inv_get
    if _newclass:
        trivial_chi1inv = _swig_property(_meep.structure_chunk_trivial_chi1inv_get, _meep.structure_chunk_trivial_chi1inv_set)
    __swig_setmethods__["conductivity"] = _meep.structure_chunk_conductivity_set
    __swig_getmethods__["conductivity"] = _meep.structure_chunk_conductivity_get
    if _newclass:
        conductivity = _swig_property(_meep.structure_chunk_conductivity_get, _meep.structure_chunk_conductivity_set)
    __swig_setmethods__["condinv"] = _meep.structure_chunk_condinv_set
    __swig_getmethods__["condinv"] = _meep.structure_chunk_condinv_get
    if _newclass:
        condinv = _swig_property(_meep.structure_chunk_condinv_get, _meep.structure_chunk_condinv_set)
    __swig_setmethods__["condinv_stale"] = _meep.structure_chunk_condinv_stale_set
    __swig_getmethods__["condinv_stale"] = _meep.structure_chunk_condinv_stale_get
    if _newclass:
        condinv_stale = _swig_property(_meep.structure_chunk_condinv_stale_get, _meep.structure_chunk_condinv_stale_set)
    __swig_setmethods__["sig"] = _meep.structure_chunk_sig_set
    __swig_getmethods__["sig"] = _meep.structure_chunk_sig_get
    if _newclass:
        sig = _swig_property(_meep.structure_chunk_sig_get, _meep.structure_chunk_sig_set)
    __swig_setmethods__["kap"] = _meep.structure_chunk_kap_set
    __swig_getmethods__["kap"] = _meep.structure_chunk_kap_get
    if _newclass:
        kap = _swig_property(_meep.structure_chunk_kap_get, _meep.structure_chunk_kap_set)
    __swig_setmethods__["siginv"] = _meep.structure_chunk_siginv_set
    __swig_getmethods__["siginv"] = _meep.structure_chunk_siginv_get
    if _newclass:
        siginv = _swig_property(_meep.structure_chunk_siginv_get, _meep.structure_chunk_siginv_set)
    __swig_setmethods__["sigsize"] = _meep.structure_chunk_sigsize_set
    __swig_getmethods__["sigsize"] = _meep.structure_chunk_sigsize_get
    if _newclass:
        sigsize = _swig_property(_meep.structure_chunk_sigsize_get, _meep.structure_chunk_sigsize_set)
    __swig_setmethods__["gv"] = _meep.structure_chunk_gv_set
    __swig_getmethods__["gv"] = _meep.structure_chunk_gv_get
    if _newclass:
        gv = _swig_property(_meep.structure_chunk_gv_get, _meep.structure_chunk_gv_set)
    __swig_setmethods__["v"] = _meep.structure_chunk_v_set
    __swig_getmethods__["v"] = _meep.structure_chunk_v_get
    if _newclass:
        v = _swig_property(_meep.structure_chunk_v_get, _meep.structure_chunk_v_set)
    __swig_setmethods__["chiP"] = _meep.structure_chunk_chiP_set
    __swig_getmethods__["chiP"] = _meep.structure_chunk_chiP_get
    if _newclass:
        chiP = _swig_property(_meep.structure_chunk_chiP_get, _meep.structure_chunk_chiP_set)
    __swig_setmethods__["cost"] = _meep.structure_chunk_cost_set
    __swig_getmethods__["cost"] = _meep.structure_chunk_cost_get
    if _newclass:
        cost = _swig_property(_meep.structure_chunk_cost_get, _meep.structure_chunk_cost_set)
    __swig_setmethods__["refcount"] = _meep.structure_chunk_refcount_set
    __swig_getmethods__["refcount"] = _meep.structure_chunk_refcount_get
    if _newclass:
        refcount = _swig_property(_meep.structure_chunk_refcount_get, _meep.structure_chunk_refcount_set)
    __swig_destroy__ = _meep.delete_structure_chunk
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _meep.new_structure_chunk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_chi1inv(self, c, eps, use_anisotropic_averaging, tol, maxeval):
        return _meep.structure_chunk_set_chi1inv(self, c, eps, use_anisotropic_averaging, tol, maxeval)

    def has_chi(self, c, d):
        return _meep.structure_chunk_has_chi(self, c, d)

    def has_chisigma(self, c, d):
        return _meep.structure_chunk_has_chisigma(self, c, d)

    def has_chi1inv(self, c, d):
        return _meep.structure_chunk_has_chi1inv(self, c, d)

    def set_conductivity(self, c, eps):
        return _meep.structure_chunk_set_conductivity(self, c, eps)

    def update_condinv(self):
        return _meep.structure_chunk_update_condinv(self)

    def set_chi3(self, c, eps):
        return _meep.structure_chunk_set_chi3(self, c, eps)

    def set_chi2(self, c, eps):
        return _meep.structure_chunk_set_chi2(self, c, eps)

    def use_pml(self, arg2, dx, boundary_loc, Rasymptotic, mean_stretch, pml_profile, pml_profile_data, pml_profile_integral, pml_profile_integral_u):
        return _meep.structure_chunk_use_pml(self, arg2, dx, boundary_loc, Rasymptotic, mean_stretch, pml_profile, pml_profile_data, pml_profile_integral, pml_profile_integral_u)

    def add_susceptibility(self, sigma, ft, sus):
        return _meep.structure_chunk_add_susceptibility(self, sigma, ft, sus)

    def mix_with(self, arg2, arg3):
        return _meep.structure_chunk_mix_with(self, arg2, arg3)

    def n_proc(self):
        return _meep.structure_chunk_n_proc(self)

    def is_mine(self):
        return _meep.structure_chunk_is_mine(self)

    def remove_susceptibilities(self):
        return _meep.structure_chunk_remove_susceptibilities(self)

    def get_chi1inv_at_pt(self, arg2, arg3, idx, frequency=0):
        return _meep.structure_chunk_get_chi1inv_at_pt(self, arg2, arg3, idx, frequency)

    def get_chi1inv(self, arg2, arg3, iloc, frequency=0):
        return _meep.structure_chunk_get_chi1inv(self, arg2, arg3, iloc, frequency)

    def get_inveps(self, c, d, iloc, frequency=0):
        return _meep.structure_chunk_get_inveps(self, c, d, iloc, frequency)

    def max_eps(self):
        return _meep.structure_chunk_max_eps(self)
structure_chunk_swigregister = _meep.structure_chunk_swigregister
structure_chunk_swigregister(structure_chunk)

class boundary_region(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, boundary_region, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, boundary_region, name)
    __repr__ = _swig_repr
    NOTHING_SPECIAL = _meep.boundary_region_NOTHING_SPECIAL
    PML = _meep.boundary_region_PML

    def __init__(self, *args):
        this = _meep.new_boundary_region(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_boundary_region
    __del__ = lambda self: None

    def boundary_region_assign(self, r):
        return _meep.boundary_region_boundary_region_assign(self, r)

    def __add__(self, r0):
        return _meep.boundary_region___add__(self, r0)

    def __mul__(self, strength_mult):
        return _meep.boundary_region___mul__(self, strength_mult)

    def br_apply(self, *args):
        return _meep.boundary_region_br_apply(self, *args)

    def check_ok(self, gv):
        return _meep.boundary_region_check_ok(self, gv)
boundary_region_swigregister = _meep.boundary_region_swigregister
boundary_region_swigregister(boundary_region)


def pml(*args):
    return _meep.pml(*args)
pml = _meep.pml
class structure(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, structure, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, structure, name)
    __repr__ = _swig_repr
    __swig_setmethods__["chunks"] = _meep.structure_chunks_set
    __swig_getmethods__["chunks"] = _meep.structure_chunks_get
    if _newclass:
        chunks = _swig_property(_meep.structure_chunks_get, _meep.structure_chunks_set)
    __swig_setmethods__["num_chunks"] = _meep.structure_num_chunks_set
    __swig_getmethods__["num_chunks"] = _meep.structure_num_chunks_get
    if _newclass:
        num_chunks = _swig_property(_meep.structure_num_chunks_get, _meep.structure_num_chunks_set)
    __swig_setmethods__["shared_chunks"] = _meep.structure_shared_chunks_set
    __swig_getmethods__["shared_chunks"] = _meep.structure_shared_chunks_get
    if _newclass:
        shared_chunks = _swig_property(_meep.structure_shared_chunks_get, _meep.structure_shared_chunks_set)
    __swig_setmethods__["gv"] = _meep.structure_gv_set
    __swig_getmethods__["gv"] = _meep.structure_gv_get
    if _newclass:
        gv = _swig_property(_meep.structure_gv_get, _meep.structure_gv_set)
    __swig_setmethods__["user_volume"] = _meep.structure_user_volume_set
    __swig_getmethods__["user_volume"] = _meep.structure_user_volume_get
    if _newclass:
        user_volume = _swig_property(_meep.structure_user_volume_get, _meep.structure_user_volume_set)
    __swig_setmethods__["a"] = _meep.structure_a_set
    __swig_getmethods__["a"] = _meep.structure_a_get
    if _newclass:
        a = _swig_property(_meep.structure_a_get, _meep.structure_a_set)
    __swig_setmethods__["Courant"] = _meep.structure_Courant_set
    __swig_getmethods__["Courant"] = _meep.structure_Courant_get
    if _newclass:
        Courant = _swig_property(_meep.structure_Courant_get, _meep.structure_Courant_set)
    __swig_setmethods__["dt"] = _meep.structure_dt_set
    __swig_getmethods__["dt"] = _meep.structure_dt_get
    if _newclass:
        dt = _swig_property(_meep.structure_dt_get, _meep.structure_dt_set)
    __swig_setmethods__["v"] = _meep.structure_v_set
    __swig_getmethods__["v"] = _meep.structure_v_get
    if _newclass:
        v = _swig_property(_meep.structure_v_get, _meep.structure_v_set)
    __swig_setmethods__["S"] = _meep.structure_S_set
    __swig_getmethods__["S"] = _meep.structure_S_get
    if _newclass:
        S = _swig_property(_meep.structure_S_get, _meep.structure_S_set)
    __swig_setmethods__["outdir"] = _meep.structure_outdir_set
    __swig_getmethods__["outdir"] = _meep.structure_outdir_get
    if _newclass:
        outdir = _swig_property(_meep.structure_outdir_get, _meep.structure_outdir_set)
    __swig_setmethods__["effort_volumes"] = _meep.structure_effort_volumes_set
    __swig_getmethods__["effort_volumes"] = _meep.structure_effort_volumes_get
    if _newclass:
        effort_volumes = _swig_property(_meep.structure_effort_volumes_get, _meep.structure_effort_volumes_set)
    __swig_setmethods__["effort"] = _meep.structure_effort_set
    __swig_getmethods__["effort"] = _meep.structure_effort_get
    if _newclass:
        effort = _swig_property(_meep.structure_effort_get, _meep.structure_effort_set)
    __swig_setmethods__["num_effort_volumes"] = _meep.structure_num_effort_volumes_set
    __swig_getmethods__["num_effort_volumes"] = _meep.structure_num_effort_volumes_get
    if _newclass:
        num_effort_volumes = _swig_property(_meep.structure_num_effort_volumes_get, _meep.structure_num_effort_volumes_set)
    __swig_destroy__ = _meep.delete_structure
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _meep.new_structure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_materials(self, mat, use_anisotropic_averaging=True, tol=1e-4, maxeval=100000):
        return _meep.structure_set_materials(self, mat, use_anisotropic_averaging, tol, maxeval)

    def set_chi1inv(self, c, eps, use_anisotropic_averaging=True, tol=1e-4, maxeval=100000):
        return _meep.structure_set_chi1inv(self, c, eps, use_anisotropic_averaging, tol, maxeval)

    def has_chi(self, c, d):
        return _meep.structure_has_chi(self, c, d)

    def set_epsilon(self, *args):
        return _meep.structure_set_epsilon(self, *args)

    def set_mu(self, *args):
        return _meep.structure_set_mu(self, *args)

    def set_conductivity(self, *args):
        return _meep.structure_set_conductivity(self, *args)

    def set_chi3(self, *args):
        return _meep.structure_set_chi3(self, *args)

    def set_chi2(self, *args):
        return _meep.structure_set_chi2(self, *args)

    def add_susceptibility(self, *args):
        return _meep.structure_add_susceptibility(self, *args)

    def remove_susceptibilities(self):
        return _meep.structure_remove_susceptibilities(self)

    def set_output_directory(self, name):
        return _meep.structure_set_output_directory(self, name)

    def mix_with(self, arg2, arg3):
        return _meep.structure_mix_with(self, arg2, arg3)

    def equal_layout(self, arg2):
        return _meep.structure_equal_layout(self, arg2)

    def print_layout(self):
        return _meep.structure_print_layout(self)

    def get_chunk_volumes(self):
        return _meep.structure_get_chunk_volumes(self)

    def get_chunk_owners(self):
        return _meep.structure_get_chunk_owners(self)

    def dump(self, filename):
        return _meep.structure_dump(self, filename)

    def dump_chunk_layout(self, filename):
        return _meep.structure_dump_chunk_layout(self, filename)

    def load(self, filename):
        return _meep.structure_load(self, filename)

    def load_chunk_layout(self, *args):
        return _meep.structure_load_chunk_layout(self, *args)

    def get_chi1inv(self, *args):
        return _meep.structure_get_chi1inv(self, *args)

    def get_inveps(self, *args):
        return _meep.structure_get_inveps(self, *args)

    def get_eps(self, loc, frequency=0):
        return _meep.structure_get_eps(self, loc, frequency)

    def get_mu(self, loc, frequency=0):
        return _meep.structure_get_mu(self, loc, frequency)

    def max_eps(self):
        return _meep.structure_max_eps(self)

    def estimated_cost(self, *args):
        return _meep.structure_estimated_cost(self, *args)
structure_swigregister = _meep.structure_swigregister
structure_swigregister(structure)


def choose_chunkdivision(gv, v, num_chunks, s):
    return _meep.choose_chunkdivision(gv, v, num_chunks, s)
choose_chunkdivision = _meep.choose_chunkdivision
class src_time(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, src_time, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, src_time, name)
    __repr__ = _swig_repr
    __swig_setmethods__["is_integrated"] = _meep.src_time_is_integrated_set
    __swig_getmethods__["is_integrated"] = _meep.src_time_is_integrated_get
    if _newclass:
        is_integrated = _swig_property(_meep.src_time_is_integrated_get, _meep.src_time_is_integrated_set)
    __swig_destroy__ = _meep.delete_src_time
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _meep.new_src_time(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def update(self, time, dt):
        return _meep.src_time_update(self, time, dt)

    def current(self, *args):
        return _meep.src_time_current(self, *args)

    def last_time_max(self, *args):
        return _meep.src_time_last_time_max(self, *args)

    def add_to(self, others, added):
        return _meep.src_time_add_to(self, others, added)
    __swig_setmethods__["next"] = _meep.src_time_next_set
    __swig_getmethods__["next"] = _meep.src_time_next_get
    if _newclass:
        next = _swig_property(_meep.src_time_next_get, _meep.src_time_next_set)

    def dipole(self, *args):
        return _meep.src_time_dipole(self, *args)

    def last_time(self):
        return _meep.src_time_last_time(self)

    def clone(self):
        return _meep.src_time_clone(self)

    def is_equal(self, t):
        return _meep.src_time_is_equal(self, t)

    def frequency(self):
        return _meep.src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.src_time_set_frequency(self, f)
src_time_swigregister = _meep.src_time_swigregister
src_time_swigregister(src_time)


def src_times_equal(t1, t2):
    return _meep.src_times_equal(t1, t2)
src_times_equal = _meep.src_times_equal
class gaussian_src_time(src_time):
    __swig_setmethods__ = {}
    for _s in [src_time]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, gaussian_src_time, name, value)
    __swig_getmethods__ = {}
    for _s in [src_time]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, gaussian_src_time, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_gaussian_src_time(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_gaussian_src_time
    __del__ = lambda self: None

    def dipole(self, time):
        return _meep.gaussian_src_time_dipole(self, time)

    def last_time(self):
        return _meep.gaussian_src_time_last_time(self)

    def clone(self):
        return _meep.gaussian_src_time_clone(self)

    def is_equal(self, t):
        return _meep.gaussian_src_time_is_equal(self, t)

    def frequency(self):
        return _meep.gaussian_src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.gaussian_src_time_set_frequency(self, f)

    def fourier_transform(self, f):
        return _meep.gaussian_src_time_fourier_transform(self, f)
gaussian_src_time_swigregister = _meep.gaussian_src_time_swigregister
gaussian_src_time_swigregister(gaussian_src_time)

class continuous_src_time(src_time):
    __swig_setmethods__ = {}
    for _s in [src_time]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, continuous_src_time, name, value)
    __swig_getmethods__ = {}
    for _s in [src_time]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, continuous_src_time, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_continuous_src_time(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_continuous_src_time
    __del__ = lambda self: None

    def dipole(self, time):
        return _meep.continuous_src_time_dipole(self, time)

    def last_time(self):
        return _meep.continuous_src_time_last_time(self)

    def clone(self):
        return _meep.continuous_src_time_clone(self)

    def is_equal(self, t):
        return _meep.continuous_src_time_is_equal(self, t)

    def frequency(self):
        return _meep.continuous_src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.continuous_src_time_set_frequency(self, f)
continuous_src_time_swigregister = _meep.continuous_src_time_swigregister
continuous_src_time_swigregister(continuous_src_time)

class custom_src_time(src_time):
    __swig_setmethods__ = {}
    for _s in [src_time]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, custom_src_time, name, value)
    __swig_getmethods__ = {}
    for _s in [src_time]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, custom_src_time, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_custom_src_time(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_custom_src_time
    __del__ = lambda self: None

    def current(self, time, dt):
        return _meep.custom_src_time_current(self, time, dt)

    def dipole(self, time):
        return _meep.custom_src_time_dipole(self, time)

    def last_time(self):
        return _meep.custom_src_time_last_time(self)

    def clone(self):
        return _meep.custom_src_time_clone(self)

    def is_equal(self, t):
        return _meep.custom_src_time_is_equal(self, t)

    def frequency(self):
        return _meep.custom_src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.custom_src_time_set_frequency(self, f)
custom_src_time_swigregister = _meep.custom_src_time_swigregister
custom_src_time_swigregister(custom_src_time)

class monitor_point(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, monitor_point, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, monitor_point, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _meep.new_monitor_point()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_monitor_point
    __del__ = lambda self: None
    __swig_setmethods__["loc"] = _meep.monitor_point_loc_set
    __swig_getmethods__["loc"] = _meep.monitor_point_loc_get
    if _newclass:
        loc = _swig_property(_meep.monitor_point_loc_get, _meep.monitor_point_loc_set)
    __swig_setmethods__["t"] = _meep.monitor_point_t_set
    __swig_getmethods__["t"] = _meep.monitor_point_t_get
    if _newclass:
        t = _swig_property(_meep.monitor_point_t_get, _meep.monitor_point_t_set)
    __swig_setmethods__["f"] = _meep.monitor_point_f_set
    __swig_getmethods__["f"] = _meep.monitor_point_f_get
    if _newclass:
        f = _swig_property(_meep.monitor_point_f_get, _meep.monitor_point_f_set)
    __swig_setmethods__["next"] = _meep.monitor_point_next_set
    __swig_getmethods__["next"] = _meep.monitor_point_next_get
    if _newclass:
        next = _swig_property(_meep.monitor_point_next_get, _meep.monitor_point_next_set)

    def get_component(self, arg2):
        return _meep.monitor_point_get_component(self, arg2)

    def poynting_in_direction(self, *args):
        return _meep.monitor_point_poynting_in_direction(self, *args)

    def fourier_transform(self, w, a, f, numout, fmin=0.0, fmax=0.0, maxbands=100):
        return _meep.monitor_point_fourier_transform(self, w, a, f, numout, fmin, fmax, maxbands)

    def harminv(self, w, a, f, numout, fmin, fmax, maxbands):
        return _meep.monitor_point_harminv(self, w, a, f, numout, fmin, fmax, maxbands)
monitor_point_swigregister = _meep.monitor_point_swigregister
monitor_point_swigregister(monitor_point)

class dft_chunk(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_chunk, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_chunk, name)
    __repr__ = _swig_repr

    def __init__(self, fc_, is_, ie_, s0_, s1_, e0_, e1_, dV0_, dV1_, c_, use_centered_grid, phase_factor, shift_, S_, sn_, data_):
        this = _meep.new_dft_chunk(fc_, is_, ie_, s0_, s1_, e0_, e1_, dV0_, dV1_, c_, use_centered_grid, phase_factor, shift_, S_, sn_, data_)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_dft_chunk
    __del__ = lambda self: None

    def update_dft(self, time):
        return _meep.dft_chunk_update_dft(self, time)

    def scale_dft(self, scale):
        return _meep.dft_chunk_scale_dft(self, scale)

    def process_dft_component(self, rank, ds, min_corner, max_corner, num_freq, file, buffer, reim, field_array, mode1_data, mode2_data, ic_conjugate, retain_interp_weights, parent):
        return _meep.dft_chunk_process_dft_component(self, rank, ds, min_corner, max_corner, num_freq, file, buffer, reim, field_array, mode1_data, mode2_data, ic_conjugate, retain_interp_weights, parent)

    def __isub__(self, chunk):
        return _meep.dft_chunk___isub__(self, chunk)
    __swig_setmethods__["omega"] = _meep.dft_chunk_omega_set
    __swig_getmethods__["omega"] = _meep.dft_chunk_omega_get
    if _newclass:
        omega = _swig_property(_meep.dft_chunk_omega_get, _meep.dft_chunk_omega_set)
    __swig_setmethods__["c"] = _meep.dft_chunk_c_set
    __swig_getmethods__["c"] = _meep.dft_chunk_c_get
    if _newclass:
        c = _swig_property(_meep.dft_chunk_c_get, _meep.dft_chunk_c_set)
    __swig_setmethods__["N"] = _meep.dft_chunk_N_set
    __swig_getmethods__["N"] = _meep.dft_chunk_N_get
    if _newclass:
        N = _swig_property(_meep.dft_chunk_N_get, _meep.dft_chunk_N_set)
    __swig_setmethods__["dft"] = _meep.dft_chunk_dft_set
    __swig_getmethods__["dft"] = _meep.dft_chunk_dft_get
    if _newclass:
        dft = _swig_property(_meep.dft_chunk_dft_get, _meep.dft_chunk_dft_set)
    __swig_setmethods__["next_in_chunk"] = _meep.dft_chunk_next_in_chunk_set
    __swig_getmethods__["next_in_chunk"] = _meep.dft_chunk_next_in_chunk_get
    if _newclass:
        next_in_chunk = _swig_property(_meep.dft_chunk_next_in_chunk_get, _meep.dft_chunk_next_in_chunk_set)
    __swig_setmethods__["next_in_dft"] = _meep.dft_chunk_next_in_dft_set
    __swig_getmethods__["next_in_dft"] = _meep.dft_chunk_next_in_dft_get
    if _newclass:
        next_in_dft = _swig_property(_meep.dft_chunk_next_in_dft_get, _meep.dft_chunk_next_in_dft_set)
    __swig_setmethods__["stored_weight"] = _meep.dft_chunk_stored_weight_set
    __swig_getmethods__["stored_weight"] = _meep.dft_chunk_stored_weight_get
    if _newclass:
        stored_weight = _swig_property(_meep.dft_chunk_stored_weight_get, _meep.dft_chunk_stored_weight_set)
    __swig_setmethods__["include_dV_and_interp_weights"] = _meep.dft_chunk_include_dV_and_interp_weights_set
    __swig_getmethods__["include_dV_and_interp_weights"] = _meep.dft_chunk_include_dV_and_interp_weights_get
    if _newclass:
        include_dV_and_interp_weights = _swig_property(_meep.dft_chunk_include_dV_and_interp_weights_get, _meep.dft_chunk_include_dV_and_interp_weights_set)
    __swig_setmethods__["sqrt_dV_and_interp_weights"] = _meep.dft_chunk_sqrt_dV_and_interp_weights_set
    __swig_getmethods__["sqrt_dV_and_interp_weights"] = _meep.dft_chunk_sqrt_dV_and_interp_weights_get
    if _newclass:
        sqrt_dV_and_interp_weights = _swig_property(_meep.dft_chunk_sqrt_dV_and_interp_weights_get, _meep.dft_chunk_sqrt_dV_and_interp_weights_set)
    __swig_setmethods__["extra_weight"] = _meep.dft_chunk_extra_weight_set
    __swig_getmethods__["extra_weight"] = _meep.dft_chunk_extra_weight_get
    if _newclass:
        extra_weight = _swig_property(_meep.dft_chunk_extra_weight_get, _meep.dft_chunk_extra_weight_set)
    __swig_setmethods__["fc"] = _meep.dft_chunk_fc_set
    __swig_getmethods__["fc"] = _meep.dft_chunk_fc_get
    if _newclass:
        fc = _swig_property(_meep.dft_chunk_fc_get, _meep.dft_chunk_fc_set)
    __swig_setmethods__["_is"] = _meep.dft_chunk__is_set
    __swig_getmethods__["_is"] = _meep.dft_chunk__is_get
    if _newclass:
        _is = _swig_property(_meep.dft_chunk__is_get, _meep.dft_chunk__is_set)
    __swig_setmethods__["ie"] = _meep.dft_chunk_ie_set
    __swig_getmethods__["ie"] = _meep.dft_chunk_ie_get
    if _newclass:
        ie = _swig_property(_meep.dft_chunk_ie_get, _meep.dft_chunk_ie_set)
    __swig_setmethods__["s0"] = _meep.dft_chunk_s0_set
    __swig_getmethods__["s0"] = _meep.dft_chunk_s0_get
    if _newclass:
        s0 = _swig_property(_meep.dft_chunk_s0_get, _meep.dft_chunk_s0_set)
    __swig_setmethods__["s1"] = _meep.dft_chunk_s1_set
    __swig_getmethods__["s1"] = _meep.dft_chunk_s1_get
    if _newclass:
        s1 = _swig_property(_meep.dft_chunk_s1_get, _meep.dft_chunk_s1_set)
    __swig_setmethods__["e0"] = _meep.dft_chunk_e0_set
    __swig_getmethods__["e0"] = _meep.dft_chunk_e0_get
    if _newclass:
        e0 = _swig_property(_meep.dft_chunk_e0_get, _meep.dft_chunk_e0_set)
    __swig_setmethods__["e1"] = _meep.dft_chunk_e1_set
    __swig_getmethods__["e1"] = _meep.dft_chunk_e1_get
    if _newclass:
        e1 = _swig_property(_meep.dft_chunk_e1_get, _meep.dft_chunk_e1_set)
    __swig_setmethods__["dV0"] = _meep.dft_chunk_dV0_set
    __swig_getmethods__["dV0"] = _meep.dft_chunk_dV0_get
    if _newclass:
        dV0 = _swig_property(_meep.dft_chunk_dV0_get, _meep.dft_chunk_dV0_set)
    __swig_setmethods__["dV1"] = _meep.dft_chunk_dV1_set
    __swig_getmethods__["dV1"] = _meep.dft_chunk_dV1_get
    if _newclass:
        dV1 = _swig_property(_meep.dft_chunk_dV1_get, _meep.dft_chunk_dV1_set)
    __swig_setmethods__["empty_dim"] = _meep.dft_chunk_empty_dim_set
    __swig_getmethods__["empty_dim"] = _meep.dft_chunk_empty_dim_get
    if _newclass:
        empty_dim = _swig_property(_meep.dft_chunk_empty_dim_get, _meep.dft_chunk_empty_dim_set)
    __swig_setmethods__["scale"] = _meep.dft_chunk_scale_set
    __swig_getmethods__["scale"] = _meep.dft_chunk_scale_get
    if _newclass:
        scale = _swig_property(_meep.dft_chunk_scale_get, _meep.dft_chunk_scale_set)
    __swig_setmethods__["shift"] = _meep.dft_chunk_shift_set
    __swig_getmethods__["shift"] = _meep.dft_chunk_shift_get
    if _newclass:
        shift = _swig_property(_meep.dft_chunk_shift_get, _meep.dft_chunk_shift_set)
    __swig_setmethods__["S"] = _meep.dft_chunk_S_set
    __swig_getmethods__["S"] = _meep.dft_chunk_S_get
    if _newclass:
        S = _swig_property(_meep.dft_chunk_S_get, _meep.dft_chunk_S_set)
    __swig_setmethods__["sn"] = _meep.dft_chunk_sn_set
    __swig_getmethods__["sn"] = _meep.dft_chunk_sn_get
    if _newclass:
        sn = _swig_property(_meep.dft_chunk_sn_get, _meep.dft_chunk_sn_set)
    __swig_setmethods__["dft_phase"] = _meep.dft_chunk_dft_phase_set
    __swig_getmethods__["dft_phase"] = _meep.dft_chunk_dft_phase_get
    if _newclass:
        dft_phase = _swig_property(_meep.dft_chunk_dft_phase_get, _meep.dft_chunk_dft_phase_set)
    __swig_setmethods__["avg1"] = _meep.dft_chunk_avg1_set
    __swig_getmethods__["avg1"] = _meep.dft_chunk_avg1_get
    if _newclass:
        avg1 = _swig_property(_meep.dft_chunk_avg1_get, _meep.dft_chunk_avg1_set)
    __swig_setmethods__["avg2"] = _meep.dft_chunk_avg2_set
    __swig_getmethods__["avg2"] = _meep.dft_chunk_avg2_get
    if _newclass:
        avg2 = _swig_property(_meep.dft_chunk_avg2_get, _meep.dft_chunk_avg2_set)
    __swig_setmethods__["vc"] = _meep.dft_chunk_vc_set
    __swig_getmethods__["vc"] = _meep.dft_chunk_vc_get
    if _newclass:
        vc = _swig_property(_meep.dft_chunk_vc_get, _meep.dft_chunk_vc_set)
dft_chunk_swigregister = _meep.dft_chunk_swigregister
dft_chunk_swigregister(dft_chunk)


def save_dft_hdf5(*args):
    return _meep.save_dft_hdf5(*args)
save_dft_hdf5 = _meep.save_dft_hdf5

def load_dft_hdf5(*args):
    return _meep.load_dft_hdf5(*args)
load_dft_hdf5 = _meep.load_dft_hdf5
class dft_flux(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_flux, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_flux, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_dft_flux(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def flux(self):
        return _meep.dft_flux_flux(self)

    def __isub__(self, fl):
        return _meep.dft_flux___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_flux_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_flux_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_flux_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_flux_remove(self)
    __swig_setmethods__["freq"] = _meep.dft_flux_freq_set
    __swig_getmethods__["freq"] = _meep.dft_flux_freq_get
    if _newclass:
        freq = _swig_property(_meep.dft_flux_freq_get, _meep.dft_flux_freq_set)
    __swig_setmethods__["E"] = _meep.dft_flux_E_set
    __swig_getmethods__["E"] = _meep.dft_flux_E_get
    if _newclass:
        E = _swig_property(_meep.dft_flux_E_get, _meep.dft_flux_E_set)
    __swig_setmethods__["H"] = _meep.dft_flux_H_set
    __swig_getmethods__["H"] = _meep.dft_flux_H_get
    if _newclass:
        H = _swig_property(_meep.dft_flux_H_get, _meep.dft_flux_H_set)
    __swig_setmethods__["cE"] = _meep.dft_flux_cE_set
    __swig_getmethods__["cE"] = _meep.dft_flux_cE_get
    if _newclass:
        cE = _swig_property(_meep.dft_flux_cE_get, _meep.dft_flux_cE_set)
    __swig_setmethods__["cH"] = _meep.dft_flux_cH_set
    __swig_getmethods__["cH"] = _meep.dft_flux_cH_get
    if _newclass:
        cH = _swig_property(_meep.dft_flux_cH_get, _meep.dft_flux_cH_set)
    __swig_setmethods__["where"] = _meep.dft_flux_where_set
    __swig_getmethods__["where"] = _meep.dft_flux_where_get
    if _newclass:
        where = _swig_property(_meep.dft_flux_where_get, _meep.dft_flux_where_set)
    __swig_setmethods__["normal_direction"] = _meep.dft_flux_normal_direction_set
    __swig_getmethods__["normal_direction"] = _meep.dft_flux_normal_direction_get
    if _newclass:
        normal_direction = _swig_property(_meep.dft_flux_normal_direction_get, _meep.dft_flux_normal_direction_set)
    __swig_setmethods__["use_symmetry"] = _meep.dft_flux_use_symmetry_set
    __swig_getmethods__["use_symmetry"] = _meep.dft_flux_use_symmetry_get
    if _newclass:
        use_symmetry = _swig_property(_meep.dft_flux_use_symmetry_get, _meep.dft_flux_use_symmetry_set)
    __swig_destroy__ = _meep.delete_dft_flux
    __del__ = lambda self: None
dft_flux_swigregister = _meep.dft_flux_swigregister
dft_flux_swigregister(dft_flux)

class dft_energy(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_energy, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_energy, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_dft_energy(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def electric(self):
        return _meep.dft_energy_electric(self)

    def magnetic(self):
        return _meep.dft_energy_magnetic(self)

    def total(self):
        return _meep.dft_energy_total(self)

    def __isub__(self, fl):
        return _meep.dft_energy___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_energy_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_energy_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_energy_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_energy_remove(self)
    __swig_setmethods__["freq"] = _meep.dft_energy_freq_set
    __swig_getmethods__["freq"] = _meep.dft_energy_freq_get
    if _newclass:
        freq = _swig_property(_meep.dft_energy_freq_get, _meep.dft_energy_freq_set)
    __swig_setmethods__["E"] = _meep.dft_energy_E_set
    __swig_getmethods__["E"] = _meep.dft_energy_E_get
    if _newclass:
        E = _swig_property(_meep.dft_energy_E_get, _meep.dft_energy_E_set)
    __swig_setmethods__["H"] = _meep.dft_energy_H_set
    __swig_getmethods__["H"] = _meep.dft_energy_H_get
    if _newclass:
        H = _swig_property(_meep.dft_energy_H_get, _meep.dft_energy_H_set)
    __swig_setmethods__["D"] = _meep.dft_energy_D_set
    __swig_getmethods__["D"] = _meep.dft_energy_D_get
    if _newclass:
        D = _swig_property(_meep.dft_energy_D_get, _meep.dft_energy_D_set)
    __swig_setmethods__["B"] = _meep.dft_energy_B_set
    __swig_getmethods__["B"] = _meep.dft_energy_B_get
    if _newclass:
        B = _swig_property(_meep.dft_energy_B_get, _meep.dft_energy_B_set)
    __swig_setmethods__["where"] = _meep.dft_energy_where_set
    __swig_getmethods__["where"] = _meep.dft_energy_where_get
    if _newclass:
        where = _swig_property(_meep.dft_energy_where_get, _meep.dft_energy_where_set)
    __swig_destroy__ = _meep.delete_dft_energy
    __del__ = lambda self: None
dft_energy_swigregister = _meep.dft_energy_swigregister
dft_energy_swigregister(dft_energy)

class dft_force(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_force, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_force, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_dft_force(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def force(self):
        return _meep.dft_force_force(self)

    def __isub__(self, fl):
        return _meep.dft_force___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_force_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_force_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_force_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_force_remove(self)
    __swig_setmethods__["freq"] = _meep.dft_force_freq_set
    __swig_getmethods__["freq"] = _meep.dft_force_freq_get
    if _newclass:
        freq = _swig_property(_meep.dft_force_freq_get, _meep.dft_force_freq_set)
    __swig_setmethods__["offdiag1"] = _meep.dft_force_offdiag1_set
    __swig_getmethods__["offdiag1"] = _meep.dft_force_offdiag1_get
    if _newclass:
        offdiag1 = _swig_property(_meep.dft_force_offdiag1_get, _meep.dft_force_offdiag1_set)
    __swig_setmethods__["offdiag2"] = _meep.dft_force_offdiag2_set
    __swig_getmethods__["offdiag2"] = _meep.dft_force_offdiag2_get
    if _newclass:
        offdiag2 = _swig_property(_meep.dft_force_offdiag2_get, _meep.dft_force_offdiag2_set)
    __swig_setmethods__["diag"] = _meep.dft_force_diag_set
    __swig_getmethods__["diag"] = _meep.dft_force_diag_get
    if _newclass:
        diag = _swig_property(_meep.dft_force_diag_get, _meep.dft_force_diag_set)
    __swig_setmethods__["where"] = _meep.dft_force_where_set
    __swig_getmethods__["where"] = _meep.dft_force_where_get
    if _newclass:
        where = _swig_property(_meep.dft_force_where_get, _meep.dft_force_where_set)
    __swig_destroy__ = _meep.delete_dft_force
    __del__ = lambda self: None
dft_force_swigregister = _meep.dft_force_swigregister
dft_force_swigregister(dft_force)

class sourcedata(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sourcedata, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sourcedata, name)
    __repr__ = _swig_repr
    __swig_setmethods__["near_fd_comp"] = _meep.sourcedata_near_fd_comp_set
    __swig_getmethods__["near_fd_comp"] = _meep.sourcedata_near_fd_comp_get
    if _newclass:
        near_fd_comp = _swig_property(_meep.sourcedata_near_fd_comp_get, _meep.sourcedata_near_fd_comp_set)
    __swig_setmethods__["idx_arr"] = _meep.sourcedata_idx_arr_set
    __swig_getmethods__["idx_arr"] = _meep.sourcedata_idx_arr_get
    if _newclass:
        idx_arr = _swig_property(_meep.sourcedata_idx_arr_get, _meep.sourcedata_idx_arr_set)
    __swig_setmethods__["fc_idx"] = _meep.sourcedata_fc_idx_set
    __swig_getmethods__["fc_idx"] = _meep.sourcedata_fc_idx_get
    if _newclass:
        fc_idx = _swig_property(_meep.sourcedata_fc_idx_get, _meep.sourcedata_fc_idx_set)
    __swig_setmethods__["amp_arr"] = _meep.sourcedata_amp_arr_set
    __swig_getmethods__["amp_arr"] = _meep.sourcedata_amp_arr_get
    if _newclass:
        amp_arr = _swig_property(_meep.sourcedata_amp_arr_get, _meep.sourcedata_amp_arr_set)

    def __init__(self):
        this = _meep.new_sourcedata()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_sourcedata
    __del__ = lambda self: None
sourcedata_swigregister = _meep.sourcedata_swigregister
sourcedata_swigregister(sourcedata)

class dft_near2far(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_near2far, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_near2far, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_dft_near2far(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def farfield(self, x):
        return _meep.dft_near2far_farfield(self, x)

    def farfield_lowlevel(self, F, x):
        return _meep.dft_near2far_farfield_lowlevel(self, F, x)

    def get_farfields_array(self, where, rank, dims, N, resolution):
        return _meep.dft_near2far_get_farfields_array(self, where, rank, dims, N, resolution)

    def save_farfields(self, fname, prefix, where, resolution):
        return _meep.dft_near2far_save_farfields(self, fname, prefix, where, resolution)

    def flux(self, df, where, resolution):
        return _meep.dft_near2far_flux(self, df, where, resolution)

    def __isub__(self, fl):
        return _meep.dft_near2far___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_near2far_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_near2far_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_near2far_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_near2far_remove(self)
    __swig_setmethods__["freq"] = _meep.dft_near2far_freq_set
    __swig_getmethods__["freq"] = _meep.dft_near2far_freq_get
    if _newclass:
        freq = _swig_property(_meep.dft_near2far_freq_get, _meep.dft_near2far_freq_set)
    __swig_setmethods__["F"] = _meep.dft_near2far_F_set
    __swig_getmethods__["F"] = _meep.dft_near2far_F_get
    if _newclass:
        F = _swig_property(_meep.dft_near2far_F_get, _meep.dft_near2far_F_set)
    __swig_setmethods__["eps"] = _meep.dft_near2far_eps_set
    __swig_getmethods__["eps"] = _meep.dft_near2far_eps_get
    if _newclass:
        eps = _swig_property(_meep.dft_near2far_eps_get, _meep.dft_near2far_eps_set)
    __swig_setmethods__["mu"] = _meep.dft_near2far_mu_set
    __swig_getmethods__["mu"] = _meep.dft_near2far_mu_get
    if _newclass:
        mu = _swig_property(_meep.dft_near2far_mu_get, _meep.dft_near2far_mu_set)
    __swig_setmethods__["where"] = _meep.dft_near2far_where_set
    __swig_getmethods__["where"] = _meep.dft_near2far_where_get
    if _newclass:
        where = _swig_property(_meep.dft_near2far_where_get, _meep.dft_near2far_where_set)
    __swig_setmethods__["periodic_d"] = _meep.dft_near2far_periodic_d_set
    __swig_getmethods__["periodic_d"] = _meep.dft_near2far_periodic_d_get
    if _newclass:
        periodic_d = _swig_property(_meep.dft_near2far_periodic_d_get, _meep.dft_near2far_periodic_d_set)
    __swig_setmethods__["periodic_n"] = _meep.dft_near2far_periodic_n_set
    __swig_getmethods__["periodic_n"] = _meep.dft_near2far_periodic_n_get
    if _newclass:
        periodic_n = _swig_property(_meep.dft_near2far_periodic_n_get, _meep.dft_near2far_periodic_n_set)
    __swig_setmethods__["periodic_k"] = _meep.dft_near2far_periodic_k_set
    __swig_getmethods__["periodic_k"] = _meep.dft_near2far_periodic_k_get
    if _newclass:
        periodic_k = _swig_property(_meep.dft_near2far_periodic_k_get, _meep.dft_near2far_periodic_k_set)
    __swig_setmethods__["period"] = _meep.dft_near2far_period_set
    __swig_getmethods__["period"] = _meep.dft_near2far_period_get
    if _newclass:
        period = _swig_property(_meep.dft_near2far_period_get, _meep.dft_near2far_period_set)

    def near_sourcedata(self, x_0, farpt_list, nfar_pts, dJ):
        return _meep.dft_near2far_near_sourcedata(self, x_0, farpt_list, nfar_pts, dJ)
    __swig_destroy__ = _meep.delete_dft_near2far
    __del__ = lambda self: None
dft_near2far_swigregister = _meep.dft_near2far_swigregister
dft_near2far_swigregister(dft_near2far)

class dft_ldos(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_ldos, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_ldos, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _meep.delete_dft_ldos
    __del__ = lambda self: None

    def update(self, f):
        return _meep.dft_ldos_update(self, f)

    def ldos(self):
        return _meep.dft_ldos_ldos(self)

    def F(self):
        return _meep.dft_ldos_F(self)

    def J(self):
        return _meep.dft_ldos_J(self)
    __swig_setmethods__["freq"] = _meep.dft_ldos_freq_set
    __swig_getmethods__["freq"] = _meep.dft_ldos_freq_get
    if _newclass:
        freq = _swig_property(_meep.dft_ldos_freq_get, _meep.dft_ldos_freq_set)
dft_ldos_swigregister = _meep.dft_ldos_swigregister
dft_ldos_swigregister(dft_ldos)

def _dft_ldos(*args):
    val = _meep.new__dft_ldos(*args)
    return val

class dft_fields(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_fields, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_fields, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _meep.new_dft_fields(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def scale_dfts(self, scale):
        return _meep.dft_fields_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_fields_remove(self)
    __swig_setmethods__["freq"] = _meep.dft_fields_freq_set
    __swig_getmethods__["freq"] = _meep.dft_fields_freq_get
    if _newclass:
        freq = _swig_property(_meep.dft_fields_freq_get, _meep.dft_fields_freq_set)
    __swig_setmethods__["chunks"] = _meep.dft_fields_chunks_set
    __swig_getmethods__["chunks"] = _meep.dft_fields_chunks_get
    if _newclass:
        chunks = _swig_property(_meep.dft_fields_chunks_get, _meep.dft_fields_chunks_set)
    __swig_setmethods__["where"] = _meep.dft_fields_where_set
    __swig_getmethods__["where"] = _meep.dft_fields_where_get
    if _newclass:
        where = _swig_property(_meep.dft_fields_where_get, _meep.dft_fields_where_set)
    __swig_destroy__ = _meep.delete_dft_fields
    __del__ = lambda self: None
dft_fields_swigregister = _meep.dft_fields_swigregister
dft_fields_swigregister(dft_fields)

Incoming = _meep.Incoming
Outgoing = _meep.Outgoing
CONNECT_PHASE = _meep.CONNECT_PHASE
CONNECT_NEGATE = _meep.CONNECT_NEGATE
CONNECT_COPY = _meep.CONNECT_COPY
class polarization_state(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, polarization_state, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, polarization_state, name)
    __repr__ = _swig_repr
    __swig_setmethods__["data"] = _meep.polarization_state_data_set
    __swig_getmethods__["data"] = _meep.polarization_state_data_get
    if _newclass:
        data = _swig_property(_meep.polarization_state_data_get, _meep.polarization_state_data_set)
    __swig_setmethods__["s"] = _meep.polarization_state_s_set
    __swig_getmethods__["s"] = _meep.polarization_state_s_get
    if _newclass:
        s = _swig_property(_meep.polarization_state_s_get, _meep.polarization_state_s_set)
    __swig_setmethods__["next"] = _meep.polarization_state_next_set
    __swig_getmethods__["next"] = _meep.polarization_state_next_get
    if _newclass:
        next = _swig_property(_meep.polarization_state_next_get, _meep.polarization_state_next_set)

    def __init__(self):
        this = _meep.new_polarization_state()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_polarization_state
    __del__ = lambda self: None
polarization_state_swigregister = _meep.polarization_state_swigregister
polarization_state_swigregister(polarization_state)

class fields_chunk(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fields_chunk, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fields_chunk, name)
    __repr__ = _swig_repr
    __swig_setmethods__["f"] = _meep.fields_chunk_f_set
    __swig_getmethods__["f"] = _meep.fields_chunk_f_get
    if _newclass:
        f = _swig_property(_meep.fields_chunk_f_get, _meep.fields_chunk_f_set)
    __swig_setmethods__["f_u"] = _meep.fields_chunk_f_u_set
    __swig_getmethods__["f_u"] = _meep.fields_chunk_f_u_get
    if _newclass:
        f_u = _swig_property(_meep.fields_chunk_f_u_get, _meep.fields_chunk_f_u_set)
    __swig_setmethods__["f_w"] = _meep.fields_chunk_f_w_set
    __swig_getmethods__["f_w"] = _meep.fields_chunk_f_w_get
    if _newclass:
        f_w = _swig_property(_meep.fields_chunk_f_w_get, _meep.fields_chunk_f_w_set)
    __swig_setmethods__["f_cond"] = _meep.fields_chunk_f_cond_set
    __swig_getmethods__["f_cond"] = _meep.fields_chunk_f_cond_get
    if _newclass:
        f_cond = _swig_property(_meep.fields_chunk_f_cond_get, _meep.fields_chunk_f_cond_set)
    __swig_setmethods__["f_backup"] = _meep.fields_chunk_f_backup_set
    __swig_getmethods__["f_backup"] = _meep.fields_chunk_f_backup_get
    if _newclass:
        f_backup = _swig_property(_meep.fields_chunk_f_backup_get, _meep.fields_chunk_f_backup_set)
    __swig_setmethods__["f_u_backup"] = _meep.fields_chunk_f_u_backup_set
    __swig_getmethods__["f_u_backup"] = _meep.fields_chunk_f_u_backup_get
    if _newclass:
        f_u_backup = _swig_property(_meep.fields_chunk_f_u_backup_get, _meep.fields_chunk_f_u_backup_set)
    __swig_setmethods__["f_w_backup"] = _meep.fields_chunk_f_w_backup_set
    __swig_getmethods__["f_w_backup"] = _meep.fields_chunk_f_w_backup_get
    if _newclass:
        f_w_backup = _swig_property(_meep.fields_chunk_f_w_backup_get, _meep.fields_chunk_f_w_backup_set)
    __swig_setmethods__["f_cond_backup"] = _meep.fields_chunk_f_cond_backup_set
    __swig_getmethods__["f_cond_backup"] = _meep.fields_chunk_f_cond_backup_get
    if _newclass:
        f_cond_backup = _swig_property(_meep.fields_chunk_f_cond_backup_get, _meep.fields_chunk_f_cond_backup_set)
    __swig_setmethods__["f_w_prev"] = _meep.fields_chunk_f_w_prev_set
    __swig_getmethods__["f_w_prev"] = _meep.fields_chunk_f_w_prev_get
    if _newclass:
        f_w_prev = _swig_property(_meep.fields_chunk_f_w_prev_get, _meep.fields_chunk_f_w_prev_set)
    __swig_setmethods__["f_minus_p"] = _meep.fields_chunk_f_minus_p_set
    __swig_getmethods__["f_minus_p"] = _meep.fields_chunk_f_minus_p_get
    if _newclass:
        f_minus_p = _swig_property(_meep.fields_chunk_f_minus_p_get, _meep.fields_chunk_f_minus_p_set)
    __swig_setmethods__["f_rderiv_int"] = _meep.fields_chunk_f_rderiv_int_set
    __swig_getmethods__["f_rderiv_int"] = _meep.fields_chunk_f_rderiv_int_get
    if _newclass:
        f_rderiv_int = _swig_property(_meep.fields_chunk_f_rderiv_int_get, _meep.fields_chunk_f_rderiv_int_set)
    __swig_setmethods__["dft_chunks"] = _meep.fields_chunk_dft_chunks_set
    __swig_getmethods__["dft_chunks"] = _meep.fields_chunk_dft_chunks_get
    if _newclass:
        dft_chunks = _swig_property(_meep.fields_chunk_dft_chunks_get, _meep.fields_chunk_dft_chunks_set)
    __swig_setmethods__["zeroes"] = _meep.fields_chunk_zeroes_set
    __swig_getmethods__["zeroes"] = _meep.fields_chunk_zeroes_get
    if _newclass:
        zeroes = _swig_property(_meep.fields_chunk_zeroes_get, _meep.fields_chunk_zeroes_set)
    __swig_setmethods__["num_zeroes"] = _meep.fields_chunk_num_zeroes_set
    __swig_getmethods__["num_zeroes"] = _meep.fields_chunk_num_zeroes_get
    if _newclass:
        num_zeroes = _swig_property(_meep.fields_chunk_num_zeroes_get, _meep.fields_chunk_num_zeroes_set)
    __swig_getmethods__["connections"] = _meep.fields_chunk_connections_get
    if _newclass:
        connections = _swig_property(_meep.fields_chunk_connections_get)
    __swig_getmethods__["num_connections"] = _meep.fields_chunk_num_connections_get
    if _newclass:
        num_connections = _swig_property(_meep.fields_chunk_num_connections_get)
    __swig_setmethods__["connection_phases"] = _meep.fields_chunk_connection_phases_set
    __swig_getmethods__["connection_phases"] = _meep.fields_chunk_connection_phases_get
    if _newclass:
        connection_phases = _swig_property(_meep.fields_chunk_connection_phases_get, _meep.fields_chunk_connection_phases_set)
    __swig_setmethods__["npol"] = _meep.fields_chunk_npol_set
    __swig_getmethods__["npol"] = _meep.fields_chunk_npol_get
    if _newclass:
        npol = _swig_property(_meep.fields_chunk_npol_get, _meep.fields_chunk_npol_set)
    __swig_setmethods__["pol"] = _meep.fields_chunk_pol_set
    __swig_getmethods__["pol"] = _meep.fields_chunk_pol_get
    if _newclass:
        pol = _swig_property(_meep.fields_chunk_pol_get, _meep.fields_chunk_pol_set)
    __swig_setmethods__["a"] = _meep.fields_chunk_a_set
    __swig_getmethods__["a"] = _meep.fields_chunk_a_get
    if _newclass:
        a = _swig_property(_meep.fields_chunk_a_get, _meep.fields_chunk_a_set)
    __swig_setmethods__["Courant"] = _meep.fields_chunk_Courant_set
    __swig_getmethods__["Courant"] = _meep.fields_chunk_Courant_get
    if _newclass:
        Courant = _swig_property(_meep.fields_chunk_Courant_get, _meep.fields_chunk_Courant_set)
    __swig_setmethods__["dt"] = _meep.fields_chunk_dt_set
    __swig_getmethods__["dt"] = _meep.fields_chunk_dt_get
    if _newclass:
        dt = _swig_property(_meep.fields_chunk_dt_get, _meep.fields_chunk_dt_set)
    __swig_setmethods__["gv"] = _meep.fields_chunk_gv_set
    __swig_getmethods__["gv"] = _meep.fields_chunk_gv_get
    if _newclass:
        gv = _swig_property(_meep.fields_chunk_gv_get, _meep.fields_chunk_gv_set)
    __swig_setmethods__["v"] = _meep.fields_chunk_v_set
    __swig_getmethods__["v"] = _meep.fields_chunk_v_get
    if _newclass:
        v = _swig_property(_meep.fields_chunk_v_get, _meep.fields_chunk_v_set)
    __swig_setmethods__["m"] = _meep.fields_chunk_m_set
    __swig_getmethods__["m"] = _meep.fields_chunk_m_get
    if _newclass:
        m = _swig_property(_meep.fields_chunk_m_get, _meep.fields_chunk_m_set)
    __swig_setmethods__["zero_fields_near_cylorigin"] = _meep.fields_chunk_zero_fields_near_cylorigin_set
    __swig_getmethods__["zero_fields_near_cylorigin"] = _meep.fields_chunk_zero_fields_near_cylorigin_get
    if _newclass:
        zero_fields_near_cylorigin = _swig_property(_meep.fields_chunk_zero_fields_near_cylorigin_get, _meep.fields_chunk_zero_fields_near_cylorigin_set)
    __swig_setmethods__["beta"] = _meep.fields_chunk_beta_set
    __swig_getmethods__["beta"] = _meep.fields_chunk_beta_get
    if _newclass:
        beta = _swig_property(_meep.fields_chunk_beta_get, _meep.fields_chunk_beta_set)
    __swig_setmethods__["is_real"] = _meep.fields_chunk_is_real_set
    __swig_getmethods__["is_real"] = _meep.fields_chunk_is_real_get
    if _newclass:
        is_real = _swig_property(_meep.fields_chunk_is_real_get, _meep.fields_chunk_is_real_set)
    __swig_setmethods__["sources"] = _meep.fields_chunk_sources_set
    __swig_getmethods__["sources"] = _meep.fields_chunk_sources_get
    if _newclass:
        sources = _swig_property(_meep.fields_chunk_sources_get, _meep.fields_chunk_sources_set)
    __swig_setmethods__["new_s"] = _meep.fields_chunk_new_s_set
    __swig_getmethods__["new_s"] = _meep.fields_chunk_new_s_get
    if _newclass:
        new_s = _swig_property(_meep.fields_chunk_new_s_get, _meep.fields_chunk_new_s_set)
    __swig_setmethods__["s"] = _meep.fields_chunk_s_set
    __swig_getmethods__["s"] = _meep.fields_chunk_s_get
    if _newclass:
        s = _swig_property(_meep.fields_chunk_s_get, _meep.fields_chunk_s_set)
    __swig_setmethods__["outdir"] = _meep.fields_chunk_outdir_set
    __swig_getmethods__["outdir"] = _meep.fields_chunk_outdir_get
    if _newclass:
        outdir = _swig_property(_meep.fields_chunk_outdir_get, _meep.fields_chunk_outdir_set)
    __swig_setmethods__["chunk_idx"] = _meep.fields_chunk_chunk_idx_set
    __swig_getmethods__["chunk_idx"] = _meep.fields_chunk_chunk_idx_get
    if _newclass:
        chunk_idx = _swig_property(_meep.fields_chunk_chunk_idx_get, _meep.fields_chunk_chunk_idx_set)

    def __init__(self, *args):
        this = _meep.new_fields_chunk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_fields_chunk
    __del__ = lambda self: None

    def use_real_fields(self):
        return _meep.fields_chunk_use_real_fields(self)

    def have_component(self, c, is_complex=False):
        return _meep.fields_chunk_have_component(self, c, is_complex)

    def last_source_time(self):
        return _meep.fields_chunk_last_source_time(self)

    def get_field(self, arg2, arg3):
        return _meep.fields_chunk_get_field(self, arg2, arg3)

    def get_chi1inv(self, arg2, arg3, iloc, frequency=0):
        return _meep.fields_chunk_get_chi1inv(self, arg2, arg3, iloc, frequency)

    def backup_component(self, c):
        return _meep.fields_chunk_backup_component(self, c)

    def average_with_backup(self, c):
        return _meep.fields_chunk_average_with_backup(self, c)

    def restore_component(self, c):
        return _meep.fields_chunk_restore_component(self, c)

    def set_output_directory(self, name):
        return _meep.fields_chunk_set_output_directory(self, name)

    def count_volume(self, arg2):
        return _meep.fields_chunk_count_volume(self, arg2)

    def n_proc(self):
        return _meep.fields_chunk_n_proc(self)

    def is_mine(self):
        return _meep.fields_chunk_is_mine(self)

    def zero_metal(self, arg2):
        return _meep.fields_chunk_zero_metal(self, arg2)

    def needs_W_notowned(self, c):
        return _meep.fields_chunk_needs_W_notowned(self, c)

    def remove_sources(self):
        return _meep.fields_chunk_remove_sources(self)

    def remove_susceptibilities(self, shared_chunks):
        return _meep.fields_chunk_remove_susceptibilities(self, shared_chunks)

    def zero_fields(self):
        return _meep.fields_chunk_zero_fields(self)

    def needs_W_prev(self, c):
        return _meep.fields_chunk_needs_W_prev(self, c)

    def update_eh(self, ft, skip_w_components=False):
        return _meep.fields_chunk_update_eh(self, ft, skip_w_components)

    def alloc_f(self, c):
        return _meep.fields_chunk_alloc_f(self, c)

    def figure_out_step_plan(self):
        return _meep.fields_chunk_figure_out_step_plan(self)

    def set_solve_cw_omega(self, omega):
        return _meep.fields_chunk_set_solve_cw_omega(self, omega)

    def unset_solve_cw_omega(self):
        return _meep.fields_chunk_unset_solve_cw_omega(self)
fields_chunk_swigregister = _meep.fields_chunk_swigregister
fields_chunk_swigregister(fields_chunk)

Periodic = _meep.Periodic
Metallic = _meep.Metallic
Magnetic = _meep.Magnetic
Meep_None = _meep.Meep_None
Connecting = _meep.Connecting
Stepping = _meep.Stepping
Boundaries = _meep.Boundaries
MpiTime = _meep.MpiTime
FieldOutput = _meep.FieldOutput
FourierTransforming = _meep.FourierTransforming
MPBTime = _meep.MPBTime
GetFarfieldsTime = _meep.GetFarfieldsTime
Other = _meep.Other

def derived_component_func(c, gv, nfields, cs):
    return _meep.derived_component_func(c, gv, nfields, cs)
derived_component_func = _meep.derived_component_func
class chunkloop_field_components(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, chunkloop_field_components, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, chunkloop_field_components, name)
    __repr__ = _swig_repr

    def __init__(self, fc, cgrid, shift_phase, S, sn, num_fields, components):
        this = _meep.new_chunkloop_field_components(fc, cgrid, shift_phase, S, sn, num_fields, components)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def update_values(self, idx):
        return _meep.chunkloop_field_components_update_values(self, idx)
    __swig_setmethods__["values"] = _meep.chunkloop_field_components_values_set
    __swig_getmethods__["values"] = _meep.chunkloop_field_components_values_get
    if _newclass:
        values = _swig_property(_meep.chunkloop_field_components_values_get, _meep.chunkloop_field_components_values_set)
    __swig_destroy__ = _meep.delete_chunkloop_field_components
    __del__ = lambda self: None
chunkloop_field_components_swigregister = _meep.chunkloop_field_components_swigregister
chunkloop_field_components_swigregister(chunkloop_field_components)

class diffractedplanewave(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, diffractedplanewave, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, diffractedplanewave, name)
    __repr__ = _swig_repr

    def __init__(self, g, axis, s, p):
        this = _meep.new_diffractedplanewave(g, axis, s, p)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_g(self):
        return _meep.diffractedplanewave_get_g(self)

    def get_axis(self):
        return _meep.diffractedplanewave_get_axis(self)

    def get_s(self):
        return _meep.diffractedplanewave_get_s(self)

    def get_p(self):
        return _meep.diffractedplanewave_get_p(self)
    __swig_destroy__ = _meep.delete_diffractedplanewave
    __del__ = lambda self: None
diffractedplanewave_swigregister = _meep.diffractedplanewave_swigregister
diffractedplanewave_swigregister(diffractedplanewave)

class gaussianbeam(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, gaussianbeam, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, gaussianbeam, name)
    __repr__ = _swig_repr

    def __init__(self, x0, kdir, w0, freq, eps, mu, E0):
        this = _meep.new_gaussianbeam(x0, kdir, w0, freq, eps, mu, E0)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_fields(self, EH, x):
        return _meep.gaussianbeam_get_fields(self, EH, x)

    def get_E0(self, n):
        return _meep.gaussianbeam_get_E0(self, n)
    __swig_destroy__ = _meep.delete_gaussianbeam
    __del__ = lambda self: None
gaussianbeam_swigregister = _meep.gaussianbeam_swigregister
gaussianbeam_swigregister(gaussianbeam)

class fields(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fields, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fields, name)
    __repr__ = _swig_repr
    __swig_setmethods__["num_chunks"] = _meep.fields_num_chunks_set
    __swig_getmethods__["num_chunks"] = _meep.fields_num_chunks_get
    if _newclass:
        num_chunks = _swig_property(_meep.fields_num_chunks_get, _meep.fields_num_chunks_set)
    __swig_setmethods__["shared_chunks"] = _meep.fields_shared_chunks_set
    __swig_getmethods__["shared_chunks"] = _meep.fields_shared_chunks_get
    if _newclass:
        shared_chunks = _swig_property(_meep.fields_shared_chunks_get, _meep.fields_shared_chunks_set)
    __swig_setmethods__["chunks"] = _meep.fields_chunks_set
    __swig_getmethods__["chunks"] = _meep.fields_chunks_get
    if _newclass:
        chunks = _swig_property(_meep.fields_chunks_get, _meep.fields_chunks_set)
    __swig_setmethods__["sources"] = _meep.fields_sources_set
    __swig_getmethods__["sources"] = _meep.fields_sources_get
    if _newclass:
        sources = _swig_property(_meep.fields_sources_get, _meep.fields_sources_set)
    __swig_setmethods__["fluxes"] = _meep.fields_fluxes_set
    __swig_getmethods__["fluxes"] = _meep.fields_fluxes_get
    if _newclass:
        fluxes = _swig_property(_meep.fields_fluxes_get, _meep.fields_fluxes_set)
    __swig_setmethods__["S"] = _meep.fields_S_set
    __swig_getmethods__["S"] = _meep.fields_S_get
    if _newclass:
        S = _swig_property(_meep.fields_S_get, _meep.fields_S_set)
    __swig_setmethods__["comm_blocks"] = _meep.fields_comm_blocks_set
    __swig_getmethods__["comm_blocks"] = _meep.fields_comm_blocks_get
    if _newclass:
        comm_blocks = _swig_property(_meep.fields_comm_blocks_get, _meep.fields_comm_blocks_set)
    __swig_setmethods__["comm_sizes"] = _meep.fields_comm_sizes_set
    __swig_getmethods__["comm_sizes"] = _meep.fields_comm_sizes_get
    if _newclass:
        comm_sizes = _swig_property(_meep.fields_comm_sizes_get, _meep.fields_comm_sizes_set)

    def comm_size_tot(self, f, pair):
        return _meep.fields_comm_size_tot(self, f, pair)
    __swig_setmethods__["a"] = _meep.fields_a_set
    __swig_getmethods__["a"] = _meep.fields_a_get
    if _newclass:
        a = _swig_property(_meep.fields_a_get, _meep.fields_a_set)
    __swig_setmethods__["dt"] = _meep.fields_dt_set
    __swig_getmethods__["dt"] = _meep.fields_dt_get
    if _newclass:
        dt = _swig_property(_meep.fields_dt_get, _meep.fields_dt_set)
    __swig_setmethods__["gv"] = _meep.fields_gv_set
    __swig_getmethods__["gv"] = _meep.fields_gv_get
    if _newclass:
        gv = _swig_property(_meep.fields_gv_get, _meep.fields_gv_set)
    __swig_setmethods__["user_volume"] = _meep.fields_user_volume_set
    __swig_getmethods__["user_volume"] = _meep.fields_user_volume_get
    if _newclass:
        user_volume = _swig_property(_meep.fields_user_volume_get, _meep.fields_user_volume_set)
    __swig_setmethods__["v"] = _meep.fields_v_set
    __swig_getmethods__["v"] = _meep.fields_v_get
    if _newclass:
        v = _swig_property(_meep.fields_v_get, _meep.fields_v_set)
    __swig_setmethods__["m"] = _meep.fields_m_set
    __swig_getmethods__["m"] = _meep.fields_m_get
    if _newclass:
        m = _swig_property(_meep.fields_m_get, _meep.fields_m_set)
    __swig_setmethods__["beta"] = _meep.fields_beta_set
    __swig_getmethods__["beta"] = _meep.fields_beta_get
    if _newclass:
        beta = _swig_property(_meep.fields_beta_get, _meep.fields_beta_set)
    __swig_setmethods__["t"] = _meep.fields_t_set
    __swig_getmethods__["t"] = _meep.fields_t_get
    if _newclass:
        t = _swig_property(_meep.fields_t_get, _meep.fields_t_set)
    __swig_setmethods__["phasein_time"] = _meep.fields_phasein_time_set
    __swig_getmethods__["phasein_time"] = _meep.fields_phasein_time_get
    if _newclass:
        phasein_time = _swig_property(_meep.fields_phasein_time_get, _meep.fields_phasein_time_set)
    __swig_setmethods__["is_real"] = _meep.fields_is_real_set
    __swig_getmethods__["is_real"] = _meep.fields_is_real_get
    if _newclass:
        is_real = _swig_property(_meep.fields_is_real_get, _meep.fields_is_real_set)
    __swig_setmethods__["k"] = _meep.fields_k_set
    __swig_getmethods__["k"] = _meep.fields_k_get
    if _newclass:
        k = _swig_property(_meep.fields_k_get, _meep.fields_k_set)
    __swig_setmethods__["eikna"] = _meep.fields_eikna_set
    __swig_getmethods__["eikna"] = _meep.fields_eikna_get
    if _newclass:
        eikna = _swig_property(_meep.fields_eikna_get, _meep.fields_eikna_set)
    __swig_setmethods__["coskna"] = _meep.fields_coskna_set
    __swig_getmethods__["coskna"] = _meep.fields_coskna_get
    if _newclass:
        coskna = _swig_property(_meep.fields_coskna_get, _meep.fields_coskna_set)
    __swig_setmethods__["sinkna"] = _meep.fields_sinkna_set
    __swig_getmethods__["sinkna"] = _meep.fields_sinkna_get
    if _newclass:
        sinkna = _swig_property(_meep.fields_sinkna_get, _meep.fields_sinkna_set)
    __swig_setmethods__["boundaries"] = _meep.fields_boundaries_set
    __swig_getmethods__["boundaries"] = _meep.fields_boundaries_get
    if _newclass:
        boundaries = _swig_property(_meep.fields_boundaries_get, _meep.fields_boundaries_set)
    __swig_setmethods__["outdir"] = _meep.fields_outdir_set
    __swig_getmethods__["outdir"] = _meep.fields_outdir_get
    if _newclass:
        outdir = _swig_property(_meep.fields_outdir_get, _meep.fields_outdir_set)
    __swig_setmethods__["components_allocated"] = _meep.fields_components_allocated_set
    __swig_getmethods__["components_allocated"] = _meep.fields_components_allocated_get
    if _newclass:
        components_allocated = _swig_property(_meep.fields_components_allocated_get, _meep.fields_components_allocated_set)

    def __init__(self, *args):
        this = _meep.new_fields(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_fields
    __del__ = lambda self: None

    def equal_layout(self, f):
        return _meep.fields_equal_layout(self, f)

    def use_real_fields(self):
        return _meep.fields_use_real_fields(self)

    def zero_fields(self):
        return _meep.fields_zero_fields(self)

    def remove_sources(self):
        return _meep.fields_remove_sources(self)

    def remove_susceptibilities(self):
        return _meep.fields_remove_susceptibilities(self)

    def remove_fluxes(self):
        return _meep.fields_remove_fluxes(self)

    def reset(self):
        return _meep.fields_reset(self)

    def time_spent_on(self, arg2):
        return _meep.fields_time_spent_on(self, arg2)

    def mean_time_spent_on(self, arg2):
        return _meep.fields_mean_time_spent_on(self, arg2)

    def print_times(self):
        return _meep.fields_print_times(self)

    def set_boundary(self, arg2, arg3, arg4):
        return _meep.fields_set_boundary(self, arg2, arg3, arg4)

    def use_bloch(self, *args):
        return _meep.fields_use_bloch(self, *args)

    def lattice_vector(self, arg2):
        return _meep.fields_lattice_vector(self, arg2)

    def update_eh(self, ft, skip_w_components=False):
        return _meep.fields_update_eh(self, ft, skip_w_components)

    def total_volume(self):
        return _meep.fields_total_volume(self)

    def output_hdf5(self, *args):
        return _meep.fields_output_hdf5(self, *args)

    def open_h5file(self, *args):
        return _meep.fields_open_h5file(self, *args)

    def h5file_name(self, name, prefix=None, timestamp=False):
        return _meep.fields_h5file_name(self, name, prefix, timestamp)

    def output_times(self, fname):
        return _meep.fields_output_times(self, fname)

    def get_array_slice_dimensions(self, *args):
        return _meep.fields_get_array_slice_dimensions(self, *args)

    def get_array_slice(self, *args):
        return _meep.fields_get_array_slice(self, *args)

    def get_complex_array_slice(self, *args):
        return _meep.fields_get_complex_array_slice(self, *args)

    def get_source_slice(self, where, source_slice_component, slice=None):
        return _meep.fields_get_source_slice(self, where, source_slice_component, slice)

    def do_get_array_slice(self, where, components, fun, rfun, fun_data, vslice, frequency=0, snap=False):
        return _meep.fields_do_get_array_slice(self, where, components, fun, rfun, fun_data, vslice, frequency, snap)

    def get_array_metadata(self, where):
        return _meep.fields_get_array_metadata(self, where)
    __swig_setmethods__["last_step_output_wall_time"] = _meep.fields_last_step_output_wall_time_set
    __swig_getmethods__["last_step_output_wall_time"] = _meep.fields_last_step_output_wall_time_get
    if _newclass:
        last_step_output_wall_time = _swig_property(_meep.fields_last_step_output_wall_time_get, _meep.fields_last_step_output_wall_time_set)
    __swig_setmethods__["last_step_output_t"] = _meep.fields_last_step_output_t_set
    __swig_getmethods__["last_step_output_t"] = _meep.fields_last_step_output_t_get
    if _newclass:
        last_step_output_t = _swig_property(_meep.fields_last_step_output_t_get, _meep.fields_last_step_output_t_set)

    def step(self):
        return _meep.fields_step(self)

    def round_time(self):
        return _meep.fields_round_time(self)

    def time(self):
        return _meep.fields_time(self)

    def solve_cw(self, *args):
        return _meep.fields_solve_cw(self, *args)

    def last_source_time(self):
        return _meep.fields_last_source_time(self)

    def add_point_source(self, *args):
        return _meep.fields_add_point_source(self, *args)

    def add_volume_source(self, *args):
        return _meep.fields_add_volume_source(self, *args)

    def require_component(self, c):
        return _meep.fields_require_component(self, c)

    def add_srcdata(self, cur_data, src, n, amp_arr):
        return _meep.fields_add_srcdata(self, cur_data, src, n, amp_arr)

    def get_eigenmode(self, frequency, d, where, eig_vol, band_num, kpoint, match_frequency, parity, resolution, eigensolver_tol, kdom=None, user_mdata=None, dp=None):
        return _meep.fields_get_eigenmode(self, frequency, d, where, eig_vol, band_num, kpoint, match_frequency, parity, resolution, eigensolver_tol, kdom, user_mdata, dp)

    def add_eigenmode_source(self, *args):
        return _meep.fields_add_eigenmode_source(self, *args)

    def get_eigenmode_coefficients(self, *args):
        return _meep.fields_get_eigenmode_coefficients(self, *args)

    def initialize_field(self, arg2, f):
        return _meep.fields_initialize_field(self, arg2, f)

    def initialize_with_nth_te(self, n):
        return _meep.fields_initialize_with_nth_te(self, n)

    def initialize_with_nth_tm(self, n):
        return _meep.fields_initialize_with_nth_tm(self, n)

    def initialize_with_n_te(self, ntot):
        return _meep.fields_initialize_with_n_te(self, ntot)

    def initialize_with_n_tm(self, ntot):
        return _meep.fields_initialize_with_n_tm(self, ntot)

    def phase_in_material(self, s, time):
        return _meep.fields_phase_in_material(self, s, time)

    def is_phasing(self):
        return _meep.fields_is_phasing(self)

    def loop_in_chunks(self, *args):
        return _meep.fields_loop_in_chunks(self, *args)

    def integrate(self, *args):
        return _meep.fields_integrate(self, *args)

    def integrate2(self, *args):
        return _meep.fields_integrate2(self, *args)

    def max_abs(self, *args):
        return _meep.fields_max_abs(self, *args)

    def add_dft_pt(self, *args):
        return _meep.fields_add_dft_pt(self, *args)

    def add_dft(self, *args):
        return _meep.fields_add_dft(self, *args)

    def update_dfts(self):
        return _meep.fields_update_dfts(self)

    def add_dft_flux(self, *args):
        return _meep.fields_add_dft_flux(self, *args)

    def add_dft_flux_box(self, *args):
        return _meep.fields_add_dft_flux_box(self, *args)

    def add_dft_flux_plane(self, *args):
        return _meep.fields_add_dft_flux_plane(self, *args)

    def add_mode_monitor(self, *args):
        return _meep.fields_add_mode_monitor(self, *args)

    def add_dft_fields(self, *args):
        return _meep.fields_add_dft_fields(self, *args)

    def process_dft_component(self, *args):
        return _meep.fields_process_dft_component(self, *args)

    def output_dft_components(self, chunklists, num_chunklists, dft_volume, HDF5FileName):
        return _meep.fields_output_dft_components(self, chunklists, num_chunklists, dft_volume, HDF5FileName)

    def output_dft(self, *args):
        return _meep.fields_output_dft(self, *args)

    def get_dft_array(self, *args):
        return _meep.fields_get_dft_array(self, *args)

    def get_overlap(self, mode1_data, mode2_data, flux, num_freq, overlaps):
        return _meep.fields_get_overlap(self, mode1_data, mode2_data, flux, num_freq, overlaps)

    def get_mode_flux_overlap(self, mode_data, flux, num_freq, overlaps):
        return _meep.fields_get_mode_flux_overlap(self, mode_data, flux, num_freq, overlaps)

    def get_mode_mode_overlap(self, mode1_data, mode2_data, flux, overlaps):
        return _meep.fields_get_mode_mode_overlap(self, mode1_data, mode2_data, flux, overlaps)

    def add_dft_energy(self, *args):
        return _meep.fields_add_dft_energy(self, *args)

    def add_dft_force(self, *args):
        return _meep.fields_add_dft_force(self, *args)

    def add_dft_near2far(self, *args):
        return _meep.fields_add_dft_near2far(self, *args)

    def get_inveps(self, c, d, loc, frequency=0):
        return _meep.fields_get_inveps(self, c, d, loc, frequency)

    def get_eps(self, loc, frequency=0):
        return _meep.fields_get_eps(self, loc, frequency)

    def get_mu(self, loc, frequency=0):
        return _meep.fields_get_mu(self, loc, frequency)

    def get_point(self, p, arg3):
        return _meep.fields_get_point(self, p, arg3)

    def get_new_point(self, arg2, p=None):
        return _meep.fields_get_new_point(self, arg2, p)

    def get_field_from_comp(self, *args):
        return _meep.fields_get_field_from_comp(self, *args)

    def synchronize_magnetic_fields(self):
        return _meep.fields_synchronize_magnetic_fields(self)

    def restore_magnetic_fields(self):
        return _meep.fields_restore_magnetic_fields(self)

    def energy_in_box(self, arg2):
        return _meep.fields_energy_in_box(self, arg2)

    def electric_energy_in_box(self, arg2):
        return _meep.fields_electric_energy_in_box(self, arg2)

    def magnetic_energy_in_box(self, arg2):
        return _meep.fields_magnetic_energy_in_box(self, arg2)

    def thermo_energy_in_box(self, arg2):
        return _meep.fields_thermo_energy_in_box(self, arg2)

    def total_energy(self):
        return _meep.fields_total_energy(self)

    def field_energy_in_box(self, *args):
        return _meep.fields_field_energy_in_box(self, *args)

    def field_energy(self):
        return _meep.fields_field_energy(self)

    def flux_in_box_wrongH(self, d, arg3):
        return _meep.fields_flux_in_box_wrongH(self, d, arg3)

    def flux_in_box(self, d, arg3):
        return _meep.fields_flux_in_box(self, d, arg3)

    def add_flux_vol(self, d, where):
        return _meep.fields_add_flux_vol(self, d, where)

    def add_flux_plane(self, *args):
        return _meep.fields_add_flux_plane(self, *args)

    def electric_energy_max_in_box(self, where):
        return _meep.fields_electric_energy_max_in_box(self, where)

    def modal_volume_in_box(self, where):
        return _meep.fields_modal_volume_in_box(self, where)

    def electric_sqr_weighted_integral(self, deps, where):
        return _meep.fields_electric_sqr_weighted_integral(self, deps, where)

    def electric_energy_weighted_integral(self, f, where):
        return _meep.fields_electric_energy_weighted_integral(self, f, where)

    def set_output_directory(self, name):
        return _meep.fields_set_output_directory(self, name)

    def count_volume(self, arg2):
        return _meep.fields_count_volume(self, arg2)

    def have_component(self, arg2):
        return _meep.fields_have_component(self, arg2)

    def max_eps(self):
        return _meep.fields_max_eps(self)

    def step_boundaries(self, arg2):
        return _meep.fields_step_boundaries(self, arg2)

    def nosize_direction(self, d):
        return _meep.fields_nosize_direction(self, d)

    def normal_direction(self, where):
        return _meep.fields_normal_direction(self, where)

    def casimir_stress_dct_integral(self, dforce, dsource, mx, my, mz, ft, where, is_bloch=False):
        return _meep.fields_casimir_stress_dct_integral(self, dforce, dsource, mx, my, mz, ft, where, is_bloch)

    def set_solve_cw_omega(self, omega):
        return _meep.fields_set_solve_cw_omega(self, omega)

    def unset_solve_cw_omega(self):
        return _meep.fields_unset_solve_cw_omega(self)

    def get_field(self, *args):
        return _meep.fields_get_field(self, *args)

    def get_chi1inv(self, *args):
        return _meep.fields_get_chi1inv(self, *args)

    def locate_component_point(self, arg2, arg3, arg4):
        return _meep.fields_locate_component_point(self, arg2, arg3, arg4)

    def am_now_working_on(self, arg2):
        return _meep.fields_am_now_working_on(self, arg2)

    def finished_working(self):
        return _meep.fields_finished_working(self)

    def reset_timers(self):
        return _meep.fields_reset_timers(self)

    def is_periodic(self, side, dir):
        return _meep.fields_is_periodic(self, side, dir)
fields_swigregister = _meep.fields_swigregister
fields_swigregister(fields)

class flux_vol(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, flux_vol, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, flux_vol, name)
    __repr__ = _swig_repr

    def __init__(self, f_, d_, where_):
        this = _meep.new_flux_vol(f_, d_, where_)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_flux_vol
    __del__ = lambda self: None

    def update_half(self):
        return _meep.flux_vol_update_half(self)

    def update(self):
        return _meep.flux_vol_update(self)

    def flux(self):
        return _meep.flux_vol_flux(self)
    __swig_setmethods__["next"] = _meep.flux_vol_next_set
    __swig_getmethods__["next"] = _meep.flux_vol_next_get
    if _newclass:
        next = _swig_property(_meep.flux_vol_next_get, _meep.flux_vol_next_set)
flux_vol_swigregister = _meep.flux_vol_swigregister
flux_vol_swigregister(flux_vol)


def make_output_directory(*args):
    return _meep.make_output_directory(*args)
make_output_directory = _meep.make_output_directory

def trash_output_directory(dirname):
    return _meep.trash_output_directory(dirname)
trash_output_directory = _meep.trash_output_directory

def delete_directory(path):
    return _meep.delete_directory(path)
delete_directory = _meep.delete_directory

def create_output_file(dirname, fname):
    return _meep.create_output_file(dirname, fname)
create_output_file = _meep.create_output_file

def do_harminv(data, n, dt, fmin, fmax, maxbands, amps, freq_re, freq_im, errors=None, spectral_density=1.1, Q_thresh=50, rel_err_thresh=1e20, err_thresh=0.01, rel_amp_thresh=-1, amp_thresh=-1):
    return _meep.do_harminv(data, n, dt, fmin, fmax, maxbands, amps, freq_re, freq_im, errors, spectral_density, Q_thresh, rel_err_thresh, err_thresh, rel_amp_thresh, amp_thresh)
do_harminv = _meep.do_harminv

def make_casimir_gfunc(T, dt, sigma, ft, eps_func=None, Tfft=0):
    return _meep.make_casimir_gfunc(T, dt, sigma, ft, eps_func, Tfft)
make_casimir_gfunc = _meep.make_casimir_gfunc

def make_casimir_gfunc_kz(T, dt, sigma, ft):
    return _meep.make_casimir_gfunc_kz(T, dt, sigma, ft)
make_casimir_gfunc_kz = _meep.make_casimir_gfunc_kz

def set_random_seed(seed):
    return _meep.set_random_seed(seed)
set_random_seed = _meep.set_random_seed

def restore_random_seed():
    return _meep.restore_random_seed()
restore_random_seed = _meep.restore_random_seed

def uniform_random(a, b):
    return _meep.uniform_random(a, b)
uniform_random = _meep.uniform_random

def gaussian_random(mean, stddev):
    return _meep.gaussian_random(mean, stddev)
gaussian_random = _meep.gaussian_random

def random_int(a, b):
    return _meep.random_int(a, b)
random_int = _meep.random_int

def BesselJ(m, kr):
    return _meep.BesselJ(m, kr)
BesselJ = _meep.BesselJ

def green2d(EH, x, freq, eps, mu, x0, c0, f0):
    return _meep.green2d(EH, x, freq, eps, mu, x0, c0, f0)
green2d = _meep.green2d

def green3d(EH, x, freq, eps, mu, x0, c0, f0):
    return _meep.green3d(EH, x, freq, eps, mu, x0, c0, f0)
green3d = _meep.green3d

def destroy_eigenmode_data(vedata, destroy_mdata=True):
    return _meep.destroy_eigenmode_data(vedata, destroy_mdata)
destroy_eigenmode_data = _meep.destroy_eigenmode_data

def eigenmode_amplitude(vedata, p, c):
    return _meep.eigenmode_amplitude(vedata, p, c)
eigenmode_amplitude = _meep.eigenmode_amplitude

def get_group_velocity(vedata):
    return _meep.get_group_velocity(vedata)
get_group_velocity = _meep.get_group_velocity

def get_k(vedata):
    return _meep.get_k(vedata)
get_k = _meep.get_k

def linear_interpolate(rx, ry, rz, data, nx, ny, nz, stride):
    return _meep.linear_interpolate(rx, ry, rz, data, nx, ny, nz, stride)
linear_interpolate = _meep.linear_interpolate

def wall_time():
    return _meep.wall_time()
wall_time = _meep.wall_time
class initialize(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, initialize, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, initialize, name)
    __repr__ = _swig_repr

    def __init__(self, argc, argv):
        this = _meep.new_initialize(argc, argv)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_initialize
    __del__ = lambda self: None

    def elapsed_time(self):
        return _meep.initialize_elapsed_time(self)
initialize_swigregister = _meep.initialize_swigregister
initialize_swigregister(initialize)


def all_wait():
    return _meep.all_wait()
all_wait = _meep.all_wait

def count_processors():
    return _meep.count_processors()
count_processors = _meep.count_processors

def my_rank():
    return _meep.my_rank()
my_rank = _meep.my_rank

def am_really_master():
    return _meep.am_really_master()
am_really_master = _meep.am_really_master

def am_master():
    return _meep.am_master()
am_master = _meep.am_master

def with_mpi():
    return _meep.with_mpi()
with_mpi = _meep.with_mpi

def send(arg1, to, data, size=1):
    return _meep.send(arg1, to, data, size)
send = _meep.send

def broadcast(*args):
    return _meep.broadcast(*args)
broadcast = _meep.broadcast

def max_to_master(arg1):
    return _meep.max_to_master(arg1)
max_to_master = _meep.max_to_master

def max_to_all(*args):
    return _meep.max_to_all(*args)
max_to_all = _meep.max_to_all

def partial_sum_to_all(*args):
    return _meep.partial_sum_to_all(*args)
partial_sum_to_all = _meep.partial_sum_to_all

def sum_to_all(*args):
    return _meep.sum_to_all(*args)
sum_to_all = _meep.sum_to_all

def sum_to_master(*args):
    return _meep.sum_to_master(*args)
sum_to_master = _meep.sum_to_master

def or_to_all(*args):
    return _meep.or_to_all(*args)
or_to_all = _meep.or_to_all

def bw_or_to_all(arg1, out, size):
    return _meep.bw_or_to_all(arg1, out, size)
bw_or_to_all = _meep.bw_or_to_all

def and_to_all(*args):
    return _meep.and_to_all(*args)
and_to_all = _meep.and_to_all

def master_printf(fmt):
    return _meep.master_printf(fmt)
master_printf = _meep.master_printf

def master_printf_stderr(fmt):
    return _meep.master_printf_stderr(fmt)
master_printf_stderr = _meep.master_printf_stderr

def debug_printf(fmt):
    return _meep.debug_printf(fmt)
debug_printf = _meep.debug_printf

def master_fprintf(f, fmt):
    return _meep.master_fprintf(f, fmt)
master_fprintf = _meep.master_fprintf

def master_fopen(name, mode):
    return _meep.master_fopen(name, mode)
master_fopen = _meep.master_fopen

def master_fclose(f):
    return _meep.master_fclose(f)
master_fclose = _meep.master_fclose

def set_meep_printf_callback(func):
    return _meep.set_meep_printf_callback(func)
set_meep_printf_callback = _meep.set_meep_printf_callback

def set_meep_printf_stderr_callback(func):
    return _meep.set_meep_printf_stderr_callback(func)
set_meep_printf_stderr_callback = _meep.set_meep_printf_stderr_callback

def begin_critical_section(tag):
    return _meep.begin_critical_section(tag)
begin_critical_section = _meep.begin_critical_section

def end_critical_section(tag):
    return _meep.end_critical_section(tag)
end_critical_section = _meep.end_critical_section

def divide_parallel_processes(numgroups):
    return _meep.divide_parallel_processes(numgroups)
divide_parallel_processes = _meep.divide_parallel_processes

def begin_global_communications():
    return _meep.begin_global_communications()
begin_global_communications = _meep.begin_global_communications

def end_global_communications():
    return _meep.end_global_communications()
end_global_communications = _meep.end_global_communications

def end_divide_parallel():
    return _meep.end_divide_parallel()
end_divide_parallel = _meep.end_divide_parallel

def my_global_rank():
    return _meep.my_global_rank()
my_global_rank = _meep.my_global_rank
CYLINDRICAL = _meep.CYLINDRICAL
X_DIR = _meep.X_DIR
Y_DIR = _meep.Y_DIR
Z_DIR = _meep.Z_DIR
R_DIR = _meep.R_DIR
PHI_DIR = _meep.PHI_DIR
ALL_SIDES = _meep.ALL_SIDES
ALL_DIRECTIONS = _meep.ALL_DIRECTIONS
ENORMOUS = _meep.ENORMOUS
TINY = _meep.TINY
class dft_data(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dft_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dft_data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["num_freqs"] = _meep.dft_data_num_freqs_set
    __swig_getmethods__["num_freqs"] = _meep.dft_data_num_freqs_get
    if _newclass:
        num_freqs = _swig_property(_meep.dft_data_num_freqs_get, _meep.dft_data_num_freqs_set)
    __swig_setmethods__["num_components"] = _meep.dft_data_num_components_set
    __swig_getmethods__["num_components"] = _meep.dft_data_num_components_get
    if _newclass:
        num_components = _swig_property(_meep.dft_data_num_components_get, _meep.dft_data_num_components_set)
    __swig_setmethods__["vols"] = _meep.dft_data_vols_set
    __swig_getmethods__["vols"] = _meep.dft_data_vols_get
    if _newclass:
        vols = _swig_property(_meep.dft_data_vols_get, _meep.dft_data_vols_set)

    def __init__(self, freqs, components, volumes):
        this = _meep.new_dft_data(freqs, components, volumes)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_dft_data
    __del__ = lambda self: None
dft_data_swigregister = _meep.dft_data_swigregister
dft_data_swigregister(dft_data)

class fragment_stats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fragment_stats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fragment_stats, name)
    __repr__ = _swig_repr
    __swig_setmethods__["tol"] = _meep.fragment_stats_tol_set
    __swig_getmethods__["tol"] = _meep.fragment_stats_tol_get
    if _newclass:
        tol = _swig_property(_meep.fragment_stats_tol_get, _meep.fragment_stats_tol_set)
    __swig_setmethods__["maxeval"] = _meep.fragment_stats_maxeval_set
    __swig_getmethods__["maxeval"] = _meep.fragment_stats_maxeval_get
    if _newclass:
        maxeval = _swig_property(_meep.fragment_stats_maxeval_get, _meep.fragment_stats_maxeval_set)
    __swig_setmethods__["resolution"] = _meep.fragment_stats_resolution_set
    __swig_getmethods__["resolution"] = _meep.fragment_stats_resolution_get
    if _newclass:
        resolution = _swig_property(_meep.fragment_stats_resolution_get, _meep.fragment_stats_resolution_set)
    __swig_setmethods__["dims"] = _meep.fragment_stats_dims_set
    __swig_getmethods__["dims"] = _meep.fragment_stats_dims_get
    if _newclass:
        dims = _swig_property(_meep.fragment_stats_dims_get, _meep.fragment_stats_dims_set)
    __swig_setmethods__["geom"] = _meep.fragment_stats_geom_set
    __swig_getmethods__["geom"] = _meep.fragment_stats_geom_get
    if _newclass:
        geom = _swig_property(_meep.fragment_stats_geom_get, _meep.fragment_stats_geom_set)
    __swig_setmethods__["dft_data_list"] = _meep.fragment_stats_dft_data_list_set
    __swig_getmethods__["dft_data_list"] = _meep.fragment_stats_dft_data_list_get
    if _newclass:
        dft_data_list = _swig_property(_meep.fragment_stats_dft_data_list_get, _meep.fragment_stats_dft_data_list_set)
    __swig_setmethods__["pml_1d_vols"] = _meep.fragment_stats_pml_1d_vols_set
    __swig_getmethods__["pml_1d_vols"] = _meep.fragment_stats_pml_1d_vols_get
    if _newclass:
        pml_1d_vols = _swig_property(_meep.fragment_stats_pml_1d_vols_get, _meep.fragment_stats_pml_1d_vols_set)
    __swig_setmethods__["pml_2d_vols"] = _meep.fragment_stats_pml_2d_vols_set
    __swig_getmethods__["pml_2d_vols"] = _meep.fragment_stats_pml_2d_vols_get
    if _newclass:
        pml_2d_vols = _swig_property(_meep.fragment_stats_pml_2d_vols_get, _meep.fragment_stats_pml_2d_vols_set)
    __swig_setmethods__["pml_3d_vols"] = _meep.fragment_stats_pml_3d_vols_set
    __swig_getmethods__["pml_3d_vols"] = _meep.fragment_stats_pml_3d_vols_get
    if _newclass:
        pml_3d_vols = _swig_property(_meep.fragment_stats_pml_3d_vols_get, _meep.fragment_stats_pml_3d_vols_set)
    __swig_setmethods__["absorber_vols"] = _meep.fragment_stats_absorber_vols_set
    __swig_getmethods__["absorber_vols"] = _meep.fragment_stats_absorber_vols_get
    if _newclass:
        absorber_vols = _swig_property(_meep.fragment_stats_absorber_vols_get, _meep.fragment_stats_absorber_vols_set)
    __swig_setmethods__["extra_materials"] = _meep.fragment_stats_extra_materials_set
    __swig_getmethods__["extra_materials"] = _meep.fragment_stats_extra_materials_get
    if _newclass:
        extra_materials = _swig_property(_meep.fragment_stats_extra_materials_get, _meep.fragment_stats_extra_materials_set)
    __swig_setmethods__["split_chunks_evenly"] = _meep.fragment_stats_split_chunks_evenly_set
    __swig_getmethods__["split_chunks_evenly"] = _meep.fragment_stats_split_chunks_evenly_get
    if _newclass:
        split_chunks_evenly = _swig_property(_meep.fragment_stats_split_chunks_evenly_get, _meep.fragment_stats_split_chunks_evenly_set)
    __swig_setmethods__["eps_averaging"] = _meep.fragment_stats_eps_averaging_set
    __swig_getmethods__["eps_averaging"] = _meep.fragment_stats_eps_averaging_get
    if _newclass:
        eps_averaging = _swig_property(_meep.fragment_stats_eps_averaging_get, _meep.fragment_stats_eps_averaging_set)
    if _newclass:
        has_non_medium_material = staticmethod(_meep.fragment_stats_has_non_medium_material)
    else:
        has_non_medium_material = _meep.fragment_stats_has_non_medium_material
    if _newclass:
        init_libctl = staticmethod(_meep.fragment_stats_init_libctl)
    else:
        init_libctl = _meep.fragment_stats_init_libctl
    __swig_setmethods__["num_anisotropic_eps_pixels"] = _meep.fragment_stats_num_anisotropic_eps_pixels_set
    __swig_getmethods__["num_anisotropic_eps_pixels"] = _meep.fragment_stats_num_anisotropic_eps_pixels_get
    if _newclass:
        num_anisotropic_eps_pixels = _swig_property(_meep.fragment_stats_num_anisotropic_eps_pixels_get, _meep.fragment_stats_num_anisotropic_eps_pixels_set)
    __swig_setmethods__["num_anisotropic_mu_pixels"] = _meep.fragment_stats_num_anisotropic_mu_pixels_set
    __swig_getmethods__["num_anisotropic_mu_pixels"] = _meep.fragment_stats_num_anisotropic_mu_pixels_get
    if _newclass:
        num_anisotropic_mu_pixels = _swig_property(_meep.fragment_stats_num_anisotropic_mu_pixels_get, _meep.fragment_stats_num_anisotropic_mu_pixels_set)
    __swig_setmethods__["num_nonlinear_pixels"] = _meep.fragment_stats_num_nonlinear_pixels_set
    __swig_getmethods__["num_nonlinear_pixels"] = _meep.fragment_stats_num_nonlinear_pixels_get
    if _newclass:
        num_nonlinear_pixels = _swig_property(_meep.fragment_stats_num_nonlinear_pixels_get, _meep.fragment_stats_num_nonlinear_pixels_set)
    __swig_setmethods__["num_susceptibility_pixels"] = _meep.fragment_stats_num_susceptibility_pixels_set
    __swig_getmethods__["num_susceptibility_pixels"] = _meep.fragment_stats_num_susceptibility_pixels_get
    if _newclass:
        num_susceptibility_pixels = _swig_property(_meep.fragment_stats_num_susceptibility_pixels_get, _meep.fragment_stats_num_susceptibility_pixels_set)
    __swig_setmethods__["num_nonzero_conductivity_pixels"] = _meep.fragment_stats_num_nonzero_conductivity_pixels_set
    __swig_getmethods__["num_nonzero_conductivity_pixels"] = _meep.fragment_stats_num_nonzero_conductivity_pixels_get
    if _newclass:
        num_nonzero_conductivity_pixels = _swig_property(_meep.fragment_stats_num_nonzero_conductivity_pixels_get, _meep.fragment_stats_num_nonzero_conductivity_pixels_set)
    __swig_setmethods__["num_1d_pml_pixels"] = _meep.fragment_stats_num_1d_pml_pixels_set
    __swig_getmethods__["num_1d_pml_pixels"] = _meep.fragment_stats_num_1d_pml_pixels_get
    if _newclass:
        num_1d_pml_pixels = _swig_property(_meep.fragment_stats_num_1d_pml_pixels_get, _meep.fragment_stats_num_1d_pml_pixels_set)
    __swig_setmethods__["num_2d_pml_pixels"] = _meep.fragment_stats_num_2d_pml_pixels_set
    __swig_getmethods__["num_2d_pml_pixels"] = _meep.fragment_stats_num_2d_pml_pixels_get
    if _newclass:
        num_2d_pml_pixels = _swig_property(_meep.fragment_stats_num_2d_pml_pixels_get, _meep.fragment_stats_num_2d_pml_pixels_set)
    __swig_setmethods__["num_3d_pml_pixels"] = _meep.fragment_stats_num_3d_pml_pixels_set
    __swig_getmethods__["num_3d_pml_pixels"] = _meep.fragment_stats_num_3d_pml_pixels_get
    if _newclass:
        num_3d_pml_pixels = _swig_property(_meep.fragment_stats_num_3d_pml_pixels_get, _meep.fragment_stats_num_3d_pml_pixels_set)
    __swig_setmethods__["num_dft_pixels"] = _meep.fragment_stats_num_dft_pixels_set
    __swig_getmethods__["num_dft_pixels"] = _meep.fragment_stats_num_dft_pixels_get
    if _newclass:
        num_dft_pixels = _swig_property(_meep.fragment_stats_num_dft_pixels_get, _meep.fragment_stats_num_dft_pixels_set)
    __swig_setmethods__["num_pixels_in_box"] = _meep.fragment_stats_num_pixels_in_box_set
    __swig_getmethods__["num_pixels_in_box"] = _meep.fragment_stats_num_pixels_in_box_get
    if _newclass:
        num_pixels_in_box = _swig_property(_meep.fragment_stats_num_pixels_in_box_get, _meep.fragment_stats_num_pixels_in_box_set)
    __swig_setmethods__["box"] = _meep.fragment_stats_box_set
    __swig_getmethods__["box"] = _meep.fragment_stats_box_get
    if _newclass:
        box = _swig_property(_meep.fragment_stats_box_get, _meep.fragment_stats_box_set)

    def __init__(self, *args):
        this = _meep.new_fragment_stats(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def compute(self):
        return _meep.fragment_stats_compute(self)

    def cost(self):
        return _meep.fragment_stats_cost(self)

    def print_stats(self):
        return _meep.fragment_stats_print_stats(self)
    __swig_destroy__ = _meep.delete_fragment_stats
    __del__ = lambda self: None
fragment_stats_swigregister = _meep.fragment_stats_swigregister
fragment_stats_swigregister(fragment_stats)

def fragment_stats_has_non_medium_material():
    return _meep.fragment_stats_has_non_medium_material()
fragment_stats_has_non_medium_material = _meep.fragment_stats_has_non_medium_material

def fragment_stats_init_libctl(default_mat, ensure_per, gv, cell_size, cell_center, geom_list):
    return _meep.fragment_stats_init_libctl(default_mat, ensure_per, gv, cell_size, cell_center, geom_list)
fragment_stats_init_libctl = _meep.fragment_stats_init_libctl


def compute_fragment_stats(geom, gv, cell_size, cell_center, default_mat, dft_data_list, pml_1d_vols, pml_2d_vols, pml_3d_vols, absorber_vols, extra_materials, tol, maxeval, ensure_per, eps_averaging):
    return _meep.compute_fragment_stats(geom, gv, cell_size, cell_center, default_mat, dft_data_list, pml_1d_vols, pml_2d_vols, pml_3d_vols, absorber_vols, extra_materials, tol, maxeval, ensure_per, eps_averaging)
compute_fragment_stats = _meep.compute_fragment_stats
class absorber(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, absorber, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, absorber, name)
    __repr__ = _swig_repr
    __swig_setmethods__["thickness"] = _meep.absorber_thickness_set
    __swig_getmethods__["thickness"] = _meep.absorber_thickness_get
    if _newclass:
        thickness = _swig_property(_meep.absorber_thickness_get, _meep.absorber_thickness_set)
    __swig_setmethods__["direction"] = _meep.absorber_direction_set
    __swig_getmethods__["direction"] = _meep.absorber_direction_get
    if _newclass:
        direction = _swig_property(_meep.absorber_direction_get, _meep.absorber_direction_set)
    __swig_setmethods__["side"] = _meep.absorber_side_set
    __swig_getmethods__["side"] = _meep.absorber_side_get
    if _newclass:
        side = _swig_property(_meep.absorber_side_get, _meep.absorber_side_set)
    __swig_setmethods__["R_asymptotic"] = _meep.absorber_R_asymptotic_set
    __swig_getmethods__["R_asymptotic"] = _meep.absorber_R_asymptotic_get
    if _newclass:
        R_asymptotic = _swig_property(_meep.absorber_R_asymptotic_get, _meep.absorber_R_asymptotic_set)
    __swig_setmethods__["mean_stretch"] = _meep.absorber_mean_stretch_set
    __swig_getmethods__["mean_stretch"] = _meep.absorber_mean_stretch_get
    if _newclass:
        mean_stretch = _swig_property(_meep.absorber_mean_stretch_get, _meep.absorber_mean_stretch_set)
    __swig_setmethods__["pml_profile"] = _meep.absorber_pml_profile_set
    __swig_getmethods__["pml_profile"] = _meep.absorber_pml_profile_get
    if _newclass:
        pml_profile = _swig_property(_meep.absorber_pml_profile_get, _meep.absorber_pml_profile_set)
    __swig_setmethods__["pml_profile_data"] = _meep.absorber_pml_profile_data_set
    __swig_getmethods__["pml_profile_data"] = _meep.absorber_pml_profile_data_get
    if _newclass:
        pml_profile_data = _swig_property(_meep.absorber_pml_profile_data_get, _meep.absorber_pml_profile_data_set)

    def __init__(self):
        this = _meep.new_absorber()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_absorber
    __del__ = lambda self: None
absorber_swigregister = _meep.absorber_swigregister
absorber_swigregister(absorber)


def create_absorber_list():
    return _meep.create_absorber_list()
create_absorber_list = _meep.create_absorber_list

def destroy_absorber_list(alist):
    return _meep.destroy_absorber_list(alist)
destroy_absorber_list = _meep.destroy_absorber_list

def add_absorbing_layer(*args):
    return _meep.add_absorbing_layer(*args)
add_absorbing_layer = _meep.add_absorbing_layer

def make_vector3(x=0.0, y=0.0, z=0.0):
    return _meep.make_vector3(x, y, z)
make_vector3 = _meep.make_vector3

def set_dimensions(dims):
    return _meep.set_dimensions(dims)
set_dimensions = _meep.set_dimensions

def set_materials_from_geometry(*args):
    return _meep.set_materials_from_geometry(*args)
set_materials_from_geometry = _meep.set_materials_from_geometry

def make_dielectric(epsilon):
    return _meep.make_dielectric(epsilon)
make_dielectric = _meep.make_dielectric

def make_user_material(user_func, user_data, do_averaging):
    return _meep.make_user_material(user_func, user_data, do_averaging)
make_user_material = _meep.make_user_material

def make_file_material(eps_input_file):
    return _meep.make_file_material(eps_input_file)
make_file_material = _meep.make_file_material

def make_material_grid():
    return _meep.make_material_grid()
make_material_grid = _meep.make_material_grid

def vec_to_vector3(pt):
    return _meep.vec_to_vector3(pt)
vec_to_vector3 = _meep.vec_to_vector3

def vector3_to_vec(v3):
    return _meep.vector3_to_vec(v3)
vector3_to_vec = _meep.vector3_to_vec

def epsilon_material_grid(md, u):
    return _meep.epsilon_material_grid(md, u)
epsilon_material_grid = _meep.epsilon_material_grid

def epsilon_file_material(md, p):
    return _meep.epsilon_file_material(md, p)
epsilon_file_material = _meep.epsilon_file_material

def is_material_grid(*args):
    return _meep.is_material_grid(*args)
is_material_grid = _meep.is_material_grid

def check_offdiag(m):
    return _meep.check_offdiag(m)
check_offdiag = _meep.check_offdiag

def gv2box(v):
    return _meep.gv2box(v)
gv2box = _meep.gv2box

def update_design_parameters(matgrid, design_parameters):
    return _meep.update_design_parameters(matgrid, design_parameters)
update_design_parameters = _meep.update_design_parameters

def matgrid_val(p, tp, oi, md):
    return _meep.matgrid_val(p, tp, oi, md)
matgrid_val = _meep.matgrid_val

def material_grid_val(p, md):
    return _meep.material_grid_val(p, md)
material_grid_val = _meep.material_grid_val

def calculate_tree(v, g):
    return _meep.calculate_tree(v, g)
calculate_tree = _meep.calculate_tree

def get_material_tensor(mm, freq, tensor):
    return _meep.get_material_tensor(mm, freq, tensor)
get_material_tensor = _meep.get_material_tensor

def get_material_gradient(u, fields_a, fields_f, freq, md, field_dir, du=1.0e-3):
    return _meep.get_material_gradient(u, fields_a, fields_f, freq, md, field_dir, du)
get_material_gradient = _meep.get_material_gradient

def add_interpolate_weights(rx, ry, rz, data, nx, ny, nz, stride, scaleby, udata, ukind, uval):
    return _meep.add_interpolate_weights(rx, ry, rz, data, nx, ny, nz, stride, scaleby, udata, ukind, uval)
add_interpolate_weights = _meep.add_interpolate_weights

def material_grids_addgradient_point(v, fields_a, fields_f, field_dir, p, scalegrad, freq, geometry_tree):
    return _meep.material_grids_addgradient_point(v, fields_a, fields_f, field_dir, p, scalegrad, freq, geometry_tree)
material_grids_addgradient_point = _meep.material_grids_addgradient_point

def material_grids_addgradient(v, ng, fields_a, fields_f, frequencies, nf, scalegrad, where, geometry_tree, f):
    return _meep.material_grids_addgradient(v, ng, fields_a, fields_f, frequencies, nf, scalegrad, where, geometry_tree, f)
material_grids_addgradient = _meep.material_grids_addgradient

def with_libGDSII():
    return _meep.with_libGDSII()
with_libGDSII = _meep.with_libGDSII

def set_geometry_from_GDSII(*args):
    return _meep.set_geometry_from_GDSII(*args)
set_geometry_from_GDSII = _meep.set_geometry_from_GDSII

def get_GDSII_prisms(material, GDSIIFile, Layer=-1, zmin=0.0, zmax=0.0):
    return _meep.get_GDSII_prisms(material, GDSIIFile, Layer, zmin, zmax)
get_GDSII_prisms = _meep.get_GDSII_prisms

def get_GDSII_prism(*args):
    return _meep.get_GDSII_prism(*args)
get_GDSII_prism = _meep.get_GDSII_prism

def get_GDSII_volume(*args):
    return _meep.get_GDSII_volume(*args)
get_GDSII_volume = _meep.get_GDSII_volume

def get_GDSII_layers(GDSIIFile):
    return _meep.get_GDSII_layers(GDSIIFile)
get_GDSII_layers = _meep.get_GDSII_layers
class near_src_data(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, near_src_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, near_src_data, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.near_src_data_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.near_src_data___nonzero__(self)

    def __bool__(self):
        return _meep.near_src_data___bool__(self)

    def __len__(self):
        return _meep.near_src_data___len__(self)

    def __getslice__(self, i, j):
        return _meep.near_src_data___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.near_src_data___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.near_src_data___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.near_src_data___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.near_src_data___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.near_src_data___setitem__(self, *args)

    def pop(self):
        return _meep.near_src_data_pop(self)

    def append(self, x):
        return _meep.near_src_data_append(self, x)

    def empty(self):
        return _meep.near_src_data_empty(self)

    def size(self):
        return _meep.near_src_data_size(self)

    def swap(self, v):
        return _meep.near_src_data_swap(self, v)

    def begin(self):
        return _meep.near_src_data_begin(self)

    def end(self):
        return _meep.near_src_data_end(self)

    def rbegin(self):
        return _meep.near_src_data_rbegin(self)

    def rend(self):
        return _meep.near_src_data_rend(self)

    def clear(self):
        return _meep.near_src_data_clear(self)

    def get_allocator(self):
        return _meep.near_src_data_get_allocator(self)

    def pop_back(self):
        return _meep.near_src_data_pop_back(self)

    def erase(self, *args):
        return _meep.near_src_data_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_near_src_data(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.near_src_data_push_back(self, x)

    def front(self):
        return _meep.near_src_data_front(self)

    def back(self):
        return _meep.near_src_data_back(self)

    def assign(self, n, x):
        return _meep.near_src_data_assign(self, n, x)

    def resize(self, *args):
        return _meep.near_src_data_resize(self, *args)

    def insert(self, *args):
        return _meep.near_src_data_insert(self, *args)

    def reserve(self, n):
        return _meep.near_src_data_reserve(self, n)

    def capacity(self):
        return _meep.near_src_data_capacity(self)
    __swig_destroy__ = _meep.delete_near_src_data
    __del__ = lambda self: None
near_src_data_swigregister = _meep.near_src_data_swigregister
near_src_data_swigregister(near_src_data)

class ComplexVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.ComplexVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.ComplexVector___nonzero__(self)

    def __bool__(self):
        return _meep.ComplexVector___bool__(self)

    def __len__(self):
        return _meep.ComplexVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.ComplexVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.ComplexVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.ComplexVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.ComplexVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.ComplexVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.ComplexVector___setitem__(self, *args)

    def pop(self):
        return _meep.ComplexVector_pop(self)

    def append(self, x):
        return _meep.ComplexVector_append(self, x)

    def empty(self):
        return _meep.ComplexVector_empty(self)

    def size(self):
        return _meep.ComplexVector_size(self)

    def swap(self, v):
        return _meep.ComplexVector_swap(self, v)

    def begin(self):
        return _meep.ComplexVector_begin(self)

    def end(self):
        return _meep.ComplexVector_end(self)

    def rbegin(self):
        return _meep.ComplexVector_rbegin(self)

    def rend(self):
        return _meep.ComplexVector_rend(self)

    def clear(self):
        return _meep.ComplexVector_clear(self)

    def get_allocator(self):
        return _meep.ComplexVector_get_allocator(self)

    def pop_back(self):
        return _meep.ComplexVector_pop_back(self)

    def erase(self, *args):
        return _meep.ComplexVector_erase(self, *args)

    def __init__(self, *args):
        this = _meep.new_ComplexVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _meep.ComplexVector_push_back(self, x)

    def front(self):
        return _meep.ComplexVector_front(self)

    def back(self):
        return _meep.ComplexVector_back(self)

    def assign(self, n, x):
        return _meep.ComplexVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.ComplexVector_resize(self, *args)

    def insert(self, *args):
        return _meep.ComplexVector_insert(self, *args)

    def reserve(self, n):
        return _meep.ComplexVector_reserve(self, n)

    def capacity(self):
        return _meep.ComplexVector_capacity(self)
    __swig_destroy__ = _meep.delete_ComplexVector
    __del__ = lambda self: None
ComplexVector_swigregister = _meep.ComplexVector_swigregister
ComplexVector_swigregister(ComplexVector)

class vector3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector3, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _meep.vector3_x_set
    __swig_getmethods__["x"] = _meep.vector3_x_get
    if _newclass:
        x = _swig_property(_meep.vector3_x_get, _meep.vector3_x_set)
    __swig_setmethods__["y"] = _meep.vector3_y_set
    __swig_getmethods__["y"] = _meep.vector3_y_get
    if _newclass:
        y = _swig_property(_meep.vector3_y_get, _meep.vector3_y_set)
    __swig_setmethods__["z"] = _meep.vector3_z_set
    __swig_getmethods__["z"] = _meep.vector3_z_get
    if _newclass:
        z = _swig_property(_meep.vector3_z_get, _meep.vector3_z_set)

    def __init__(self):
        this = _meep.new_vector3()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_vector3
    __del__ = lambda self: None
vector3_swigregister = _meep.vector3_swigregister
vector3_swigregister(vector3)

class geom_box(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, geom_box, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, geom_box, name)
    __repr__ = _swig_repr
    __swig_setmethods__["low"] = _meep.geom_box_low_set
    __swig_getmethods__["low"] = _meep.geom_box_low_get
    if _newclass:
        low = _swig_property(_meep.geom_box_low_get, _meep.geom_box_low_set)
    __swig_setmethods__["high"] = _meep.geom_box_high_set
    __swig_getmethods__["high"] = _meep.geom_box_high_get
    if _newclass:
        high = _swig_property(_meep.geom_box_high_get, _meep.geom_box_high_set)

    def __init__(self):
        this = _meep.new_geom_box()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _meep.delete_geom_box
    __del__ = lambda self: None
geom_box_swigregister = _meep.geom_box_swigregister
geom_box_swigregister(geom_box)

class eigenmode_data(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, eigenmode_data, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, eigenmode_data, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mdata"] = _meep.eigenmode_data_mdata_set
    __swig_getmethods__["mdata"] = _meep.eigenmode_data_mdata_get
    if _newclass:
        mdata = _swig_property(_meep.eigenmode_data_mdata_get, _meep.eigenmode_data_mdata_set)
    __swig_setmethods__["fft_data_H"] = _meep.eigenmode_data_fft_data_H_set
    __swig_getmethods__["fft_data_H"] = _meep.eigenmode_data_fft_data_H_get
    if _newclass:
        fft_data_H = _swig_property(_meep.eigenmode_data_fft_data_H_get, _meep.eigenmode_data_fft_data_H_set)
    __swig_setmethods__["fft_data_E"] = _meep.eigenmode_data_fft_data_E_set
    __swig_getmethods__["fft_data_E"] = _meep.eigenmode_data_fft_data_E_get
    if _newclass:
        fft_data_E = _swig_property(_meep.eigenmode_data_fft_data_E_get, _meep.eigenmode_data_fft_data_E_set)
    __swig_setmethods__["H"] = _meep.eigenmode_data_H_set
    __swig_getmethods__["H"] = _meep.eigenmode_data_H_get
    if _newclass:
        H = _swig_property(_meep.eigenmode_data_H_get, _meep.eigenmode_data_H_set)
    __swig_setmethods__["n"] = _meep.eigenmode_data_n_set
    __swig_getmethods__["n"] = _meep.eigenmode_data_n_get
    if _newclass:
        n = _swig_property(_meep.eigenmode_data_n_get, _meep.eigenmode_data_n_set)
    __swig_setmethods__["s"] = _meep.eigenmode_data_s_set
    __swig_getmethods__["s"] = _meep.eigenmode_data_s_get
    if _newclass:
        s = _swig_property(_meep.eigenmode_data_s_get, _meep.eigenmode_data_s_set)
    __swig_setmethods__["Gk"] = _meep.eigenmode_data_Gk_set
    __swig_getmethods__["Gk"] = _meep.eigenmode_data_Gk_get
    if _newclass:
        Gk = _swig_property(_meep.eigenmode_data_Gk_get, _meep.eigenmode_data_Gk_set)
    __swig_setmethods__["center"] = _meep.eigenmode_data_center_set
    __swig_getmethods__["center"] = _meep.eigenmode_data_center_get
    if _newclass:
        center = _swig_property(_meep.eigenmode_data_center_get, _meep.eigenmode_data_center_set)
    __swig_setmethods__["amp_func"] = _meep.eigenmode_data_amp_func_set
    __swig_getmethods__["amp_func"] = _meep.eigenmode_data_amp_func_get
    if _newclass:
        amp_func = _swig_property(_meep.eigenmode_data_amp_func_get, _meep.eigenmode_data_amp_func_set)
    __swig_setmethods__["band_num"] = _meep.eigenmode_data_band_num_set
    __swig_getmethods__["band_num"] = _meep.eigenmode_data_band_num_get
    if _newclass:
        band_num = _swig_property(_meep.eigenmode_data_band_num_get, _meep.eigenmode_data_band_num_set)
    __swig_setmethods__["frequency"] = _meep.eigenmode_data_frequency_set
    __swig_getmethods__["frequency"] = _meep.eigenmode_data_frequency_get
    if _newclass:
        frequency = _swig_property(_meep.eigenmode_data_frequency_get, _meep.eigenmode_data_frequency_set)
    __swig_setmethods__["group_velocity"] = _meep.eigenmode_data_group_velocity_set
    __swig_getmethods__["group_velocity"] = _meep.eigenmode_data_group_velocity_get
    if _newclass:
        group_velocity = _swig_property(_meep.eigenmode_data_group_velocity_get, _meep.eigenmode_data_group_velocity_set)
    __swig_destroy__ = _meep.delete_eigenmode_data
    __del__ = lambda self: None

    def __init__(self):
        this = _meep.new_eigenmode_data()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
eigenmode_data_swigregister = _meep.eigenmode_data_swigregister
eigenmode_data_swigregister(eigenmode_data)


def _get_eigenmode(f, frequency, d, where, eig_vol, band_num, _kpoint, match_frequency, parity, resolution, eigensolver_tol, kdom):
    return _meep._get_eigenmode(f, frequency, d, where, eig_vol, band_num, _kpoint, match_frequency, parity, resolution, eigensolver_tol, kdom)
_get_eigenmode = _meep._get_eigenmode

def _get_eigenmode_Gk(emdata):
    return _meep._get_eigenmode_Gk(emdata)
_get_eigenmode_Gk = _meep._get_eigenmode_Gk

def is_point_in_object(p, o):
    return _meep.is_point_in_object(p, o)
is_point_in_object = _meep.is_point_in_object

def is_point_in_periodic_object(p, o):
    return _meep.is_point_in_periodic_object(p, o)
is_point_in_periodic_object = _meep.is_point_in_periodic_object

def display_geometric_object_info(indentby, o):
    return _meep.display_geometric_object_info(indentby, o)
display_geometric_object_info = _meep.display_geometric_object_info

def get_eigenmode_coefficients_and_kpoints(*args):
    return _meep.get_eigenmode_coefficients_and_kpoints(*args)
get_eigenmode_coefficients_and_kpoints = _meep.get_eigenmode_coefficients_and_kpoints

def _get_array_slice_dimensions(*args):
    return _meep._get_array_slice_dimensions(*args)
_get_array_slice_dimensions = _meep._get_array_slice_dimensions

AUTOMATIC = -1
CYLINDRICAL = -2
ALL = -1
ALL_COMPONENTS = Dielectric

# MPB definitions
NO_PARITY = 0
EVEN_Z = 1
ODD_Z = 2
EVEN_Y = 4
ODD_Y = 8
TE = EVEN_Z
TM = ODD_Z
PREV_PARITY = -1

inf = 1.0e20

from .geom import (
    Block,
    Cone,
    Cylinder,
    DrudeSusceptibility,
    Ellipsoid,
    FreqRange,
    GeometricObject,
    GyrotropicDrudeSusceptibility,
    GyrotropicLorentzianSusceptibility,
    GyrotropicSaturatedSusceptibility,
    Lattice,
    LorentzianSusceptibility,
    MaterialGrid,
    Matrix,
    Medium,
    MultilevelAtom,
    NoisyDrudeSusceptibility,
    NoisyLorentzianSusceptibility,
    Prism,
    Sphere,
    Susceptibility,
    Transition,
    Vector3,
    Wedge,
    check_nonnegative,
    geometric_object_duplicates,
    geometric_objects_duplicates,
    geometric_objects_lattice_duplicates,
    cartesian_to_lattice,
    lattice_to_cartesian,
    lattice_to_reciprocal,
    reciprocal_to_lattice,
    cartesian_to_reciprocal,
    reciprocal_to_cartesian,
    find_root_deriv,
    get_rotation_matrix,
)
from .simulation import (
    Absorber,
    Ldos,
    EnergyRegion,
    FluxRegion,
    ForceRegion,
    Harminv,
    Identity,
    Mirror,
    ModeRegion,
    Near2FarRegion,
    PML,
    Rotate2,
    Rotate4,
    Simulation,
    Symmetry,
    DftObj,
    DftFlux,
    DftForce,
    DftNear2Far,
    DftEnergy,
    DftFields,
    Volume,
    DiffractedPlanewave,
    after_sources,
    after_sources_and_time,
    after_time,
    at_beginning,
    at_end,
    at_every,
    at_time,
    before_time,
    combine_step_funcs,
    complexarray,
    dft_ldos,
    display_progress,
    during_sources,
    GDSII_layers,
    GDSII_prisms,
    GDSII_vol,
    get_center_and_size,
    get_eigenmode_freqs,
    get_electric_energy,
    get_energy_freqs,
    get_flux_freqs,
    get_fluxes,
    get_force_freqs,
    get_forces,
    get_group_masters,
    get_ldos_freqs,
    get_magnetic_energy,
    get_near2far_freqs,
    get_num_groups,
    get_total_energy,
    in_point,
    in_volume,
    interpolate,
    merge_subgroup_data,
    output_epsilon,
    output_mu,
    output_hpwr,
    output_dpwr,
    output_tot_pwr,
    output_bfield,
    output_bfield_x,
    output_bfield_y,
    output_bfield_z,
    output_bfield_r,
    output_bfield_p,
    output_dfield,
    output_dfield_x,
    output_dfield_y,
    output_dfield_z,
    output_dfield_r,
    output_dfield_p,
    output_efield,
    output_efield_x,
    output_efield_y,
    output_efield_z,
    output_efield_r,
    output_efield_p,
    output_hfield,
    output_hfield_x,
    output_hfield_y,
    output_hfield_z,
    output_hfield_r,
    output_hfield_p,
    output_png,
    output_poynting,
    output_poynting_x,
    output_poynting_y,
    output_poynting_z,
    output_poynting_r,
    output_poynting_p,
    output_sfield,
    output_sfield_x,
    output_sfield_y,
    output_sfield_z,
    output_sfield_r,
    output_sfield_p,
    py_v3_to_vec,
    quiet,
    scale_energy_fields,
    scale_flux_fields,
    scale_force_fields,
    scale_near2far_fields,
    stop_after_walltime,
    stop_on_interrupt,
    stop_when_fields_decayed,
    synchronized_magnetic,
    to_appended,
    vec,
    verbosity,
    when_true,
    when_false,
    with_prefix
)
from .source import (
    ContinuousSource,
    CustomSource,
    EigenModeSource,
    GaussianSource,
    IndexedSource,
    Source,
    SourceTime,
    check_positive,
    GaussianBeamSource,
)
from .visualization import (
    plot2D,
    plot3D,
    plot_fields,
    Animate2D
)
from .verbosity_mgr import (
    Verbosity
)

if with_mpi():
    try:
        from mpi4py import MPI
    except ImportError as e:
        print('\n**\n** failed to load python MPI module (mpi4py)\n**', e, '\n**\n')
        pass
    else:
# this variable reference is needed for lazy initialization of MPI
        comm = MPI.COMM_WORLD
        if am_master():
            Procs=comm.Get_size()
            (Major,Minor)=MPI.Get_version();
            print('Using MPI version {}.{}, {} processes'.format(Major, Minor, Procs));

        if not am_master():
            import os
            import sys
            saved_stdout = sys.stdout
            sys.stdout = open(os.devnull, 'w')

vacuum = Medium(epsilon=1)
air = Medium(epsilon=1)
metal = Medium(epsilon=-inf)
perfect_electric_conductor = Medium(epsilon=-inf)
perfect_magnetic_conductor = Medium(mu=-inf)
_t_start = wall_time()

def report_elapsed_time():
    print("\nElapsed run time = {:.4f} s".format(wall_time() - _t_start))

import atexit
atexit.register(report_elapsed_time)


def get_realnum_size():
    return _meep.get_realnum_size()
get_realnum_size = _meep.get_realnum_size

def create_structure_and_set_materials(cell_size, dft_data_list_, pml_1d_vols_, pml_2d_vols_, pml_3d_vols_, absorber_vols_, gv, br, sym, num_chunks, Courant, use_anisotropic_averaging, tol, maxeval, gobj_list, center, _ensure_periodicity, _default_material, alist, extra_materials, split_chunks_evenly, set_materials, existing_s, output_chunk_costs):
    return _meep.create_structure_and_set_materials(cell_size, dft_data_list_, pml_1d_vols_, pml_2d_vols_, pml_3d_vols_, absorber_vols_, gv, br, sym, num_chunks, Courant, use_anisotropic_averaging, tol, maxeval, gobj_list, center, _ensure_periodicity, _default_material, alist, extra_materials, split_chunks_evenly, set_materials, existing_s, output_chunk_costs)
create_structure_and_set_materials = _meep.create_structure_and_set_materials
# This file is compatible with both classic and new-style classes.


__version__ = '1.17'
